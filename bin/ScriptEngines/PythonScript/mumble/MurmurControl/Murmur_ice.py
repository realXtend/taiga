# **********************************************************************
#
# Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************

# Ice version 3.4.1

# <auto-generated>
#
# Generated from file `Murmur.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>

import Ice, IcePy, __builtin__

# Start of module Murmur
_M_Murmur = Ice.openModule('Murmur')
__name__ = 'Murmur'
_M_Murmur.__doc__ = '''Information and control of the murmur server. Each server has
one [Meta] interface that controls global information, and
each virtual server has a [Server] interface.'''

if not _M_Murmur.__dict__.has_key('_t_NetAddress'):
    _M_Murmur._t_NetAddress = IcePy.defineSequence('::Murmur::NetAddress', ('python:seq:tuple',), IcePy._t_byte)

if not _M_Murmur.__dict__.has_key('User'):
    _M_Murmur.User = Ice.createTempClass()
    class User(object):
        '''A connected user.'''
        def __init__(self, session=0, userid=0, mute=False, deaf=False, suppress=False, selfMute=False, selfDeaf=False, channel=0, name='', onlinesecs=0, bytespersec=0, version=0, release='', os='', osversion='', identity='', context='', comment='', address=None, tcponly=False, idlesecs=0):
            self.session = session
            self.userid = userid
            self.mute = mute
            self.deaf = deaf
            self.suppress = suppress
            self.selfMute = selfMute
            self.selfDeaf = selfDeaf
            self.channel = channel
            self.name = name
            self.onlinesecs = onlinesecs
            self.bytespersec = bytespersec
            self.version = version
            self.release = release
            self.os = os
            self.osversion = osversion
            self.identity = identity
            self.context = context
            self.comment = comment
            self.address = address
            self.tcponly = tcponly
            self.idlesecs = idlesecs

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.session)
            _h = 5 * _h + __builtin__.hash(self.userid)
            _h = 5 * _h + __builtin__.hash(self.mute)
            _h = 5 * _h + __builtin__.hash(self.deaf)
            _h = 5 * _h + __builtin__.hash(self.suppress)
            _h = 5 * _h + __builtin__.hash(self.selfMute)
            _h = 5 * _h + __builtin__.hash(self.selfDeaf)
            _h = 5 * _h + __builtin__.hash(self.channel)
            _h = 5 * _h + __builtin__.hash(self.name)
            _h = 5 * _h + __builtin__.hash(self.onlinesecs)
            _h = 5 * _h + __builtin__.hash(self.bytespersec)
            _h = 5 * _h + __builtin__.hash(self.version)
            _h = 5 * _h + __builtin__.hash(self.release)
            _h = 5 * _h + __builtin__.hash(self.os)
            _h = 5 * _h + __builtin__.hash(self.osversion)
            _h = 5 * _h + __builtin__.hash(self.identity)
            _h = 5 * _h + __builtin__.hash(self.context)
            _h = 5 * _h + __builtin__.hash(self.comment)
            if self.address:
                for _i0 in self.address:
                    _h = 5 * _h + __builtin__.hash(_i0)
            _h = 5 * _h + __builtin__.hash(self.tcponly)
            _h = 5 * _h + __builtin__.hash(self.idlesecs)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.User):
                return self.session < other.session or self.userid < other.userid or self.mute < other.mute or self.deaf < other.deaf or self.suppress < other.suppress or self.selfMute < other.selfMute or self.selfDeaf < other.selfDeaf or self.channel < other.channel or self.name < other.name or self.onlinesecs < other.onlinesecs or self.bytespersec < other.bytespersec or self.version < other.version or self.release < other.release or self.os < other.os or self.osversion < other.osversion or self.identity < other.identity or self.context < other.context or self.comment < other.comment or self.address < other.address or self.tcponly < other.tcponly or self.idlesecs < other.idlesecs
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.User):
                return self.session <= other.session or self.userid <= other.userid or self.mute <= other.mute or self.deaf <= other.deaf or self.suppress <= other.suppress or self.selfMute <= other.selfMute or self.selfDeaf <= other.selfDeaf or self.channel <= other.channel or self.name <= other.name or self.onlinesecs <= other.onlinesecs or self.bytespersec <= other.bytespersec or self.version <= other.version or self.release <= other.release or self.os <= other.os or self.osversion <= other.osversion or self.identity <= other.identity or self.context <= other.context or self.comment <= other.comment or self.address <= other.address or self.tcponly <= other.tcponly or self.idlesecs <= other.idlesecs
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.User):
                return self.session == other.session and self.userid == other.userid and self.mute == other.mute and self.deaf == other.deaf and self.suppress == other.suppress and self.selfMute == other.selfMute and self.selfDeaf == other.selfDeaf and self.channel == other.channel and self.name == other.name and self.onlinesecs == other.onlinesecs and self.bytespersec == other.bytespersec and self.version == other.version and self.release == other.release and self.os == other.os and self.osversion == other.osversion and self.identity == other.identity and self.context == other.context and self.comment == other.comment and self.address == other.address and self.tcponly == other.tcponly and self.idlesecs == other.idlesecs
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.User):
                return self.session != other.session or self.userid != other.userid or self.mute != other.mute or self.deaf != other.deaf or self.suppress != other.suppress or self.selfMute != other.selfMute or self.selfDeaf != other.selfDeaf or self.channel != other.channel or self.name != other.name or self.onlinesecs != other.onlinesecs or self.bytespersec != other.bytespersec or self.version != other.version or self.release != other.release or self.os != other.os or self.osversion != other.osversion or self.identity != other.identity or self.context != other.context or self.comment != other.comment or self.address != other.address or self.tcponly != other.tcponly or self.idlesecs != other.idlesecs
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.User):
                return self.session > other.session or self.userid > other.userid or self.mute > other.mute or self.deaf > other.deaf or self.suppress > other.suppress or self.selfMute > other.selfMute or self.selfDeaf > other.selfDeaf or self.channel > other.channel or self.name > other.name or self.onlinesecs > other.onlinesecs or self.bytespersec > other.bytespersec or self.version > other.version or self.release > other.release or self.os > other.os or self.osversion > other.osversion or self.identity > other.identity or self.context > other.context or self.comment > other.comment or self.address > other.address or self.tcponly > other.tcponly or self.idlesecs > other.idlesecs
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.User):
                return self.session >= other.session or self.userid >= other.userid or self.mute >= other.mute or self.deaf >= other.deaf or self.suppress >= other.suppress or self.selfMute >= other.selfMute or self.selfDeaf >= other.selfDeaf or self.channel >= other.channel or self.name >= other.name or self.onlinesecs >= other.onlinesecs or self.bytespersec >= other.bytespersec or self.version >= other.version or self.release >= other.release or self.os >= other.os or self.osversion >= other.osversion or self.identity >= other.identity or self.context >= other.context or self.comment >= other.comment or self.address >= other.address or self.tcponly >= other.tcponly or self.idlesecs >= other.idlesecs
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_User)

        __repr__ = __str__

    _M_Murmur._t_User = IcePy.defineStruct('::Murmur::User', User, (), (
        ('session', (), IcePy._t_int),
        ('userid', (), IcePy._t_int),
        ('mute', (), IcePy._t_bool),
        ('deaf', (), IcePy._t_bool),
        ('suppress', (), IcePy._t_bool),
        ('selfMute', (), IcePy._t_bool),
        ('selfDeaf', (), IcePy._t_bool),
        ('channel', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('onlinesecs', (), IcePy._t_int),
        ('bytespersec', (), IcePy._t_int),
        ('version', (), IcePy._t_int),
        ('release', (), IcePy._t_string),
        ('os', (), IcePy._t_string),
        ('osversion', (), IcePy._t_string),
        ('identity', (), IcePy._t_string),
        ('context', (), IcePy._t_string),
        ('comment', (), IcePy._t_string),
        ('address', (), _M_Murmur._t_NetAddress),
        ('tcponly', (), IcePy._t_bool),
        ('idlesecs', (), IcePy._t_int)
    ))

    _M_Murmur.User = User
    del User

if not _M_Murmur.__dict__.has_key('_t_IntList'):
    _M_Murmur._t_IntList = IcePy.defineSequence('::Murmur::IntList', (), IcePy._t_int)

if not _M_Murmur.__dict__.has_key('Channel'):
    _M_Murmur.Channel = Ice.createTempClass()
    class Channel(object):
        '''A channel.'''
        def __init__(self, id=0, name='', parent=0, links=None, description='', temporary=False, position=0):
            self.id = id
            self.name = name
            self.parent = parent
            self.links = links
            self.description = description
            self.temporary = temporary
            self.position = position

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.id)
            _h = 5 * _h + __builtin__.hash(self.name)
            _h = 5 * _h + __builtin__.hash(self.parent)
            if self.links:
                for _i0 in self.links:
                    _h = 5 * _h + __builtin__.hash(_i0)
            _h = 5 * _h + __builtin__.hash(self.description)
            _h = 5 * _h + __builtin__.hash(self.temporary)
            _h = 5 * _h + __builtin__.hash(self.position)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.Channel):
                return self.id < other.id or self.name < other.name or self.parent < other.parent or self.links < other.links or self.description < other.description or self.temporary < other.temporary or self.position < other.position
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.Channel):
                return self.id <= other.id or self.name <= other.name or self.parent <= other.parent or self.links <= other.links or self.description <= other.description or self.temporary <= other.temporary or self.position <= other.position
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.Channel):
                return self.id == other.id and self.name == other.name and self.parent == other.parent and self.links == other.links and self.description == other.description and self.temporary == other.temporary and self.position == other.position
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.Channel):
                return self.id != other.id or self.name != other.name or self.parent != other.parent or self.links != other.links or self.description != other.description or self.temporary != other.temporary or self.position != other.position
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.Channel):
                return self.id > other.id or self.name > other.name or self.parent > other.parent or self.links > other.links or self.description > other.description or self.temporary > other.temporary or self.position > other.position
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.Channel):
                return self.id >= other.id or self.name >= other.name or self.parent >= other.parent or self.links >= other.links or self.description >= other.description or self.temporary >= other.temporary or self.position >= other.position
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Channel)

        __repr__ = __str__

    _M_Murmur._t_Channel = IcePy.defineStruct('::Murmur::Channel', Channel, (), (
        ('id', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('parent', (), IcePy._t_int),
        ('links', (), _M_Murmur._t_IntList),
        ('description', (), IcePy._t_string),
        ('temporary', (), IcePy._t_bool),
        ('position', (), IcePy._t_int)
    ))

    _M_Murmur.Channel = Channel
    del Channel

if not _M_Murmur.__dict__.has_key('Group'):
    _M_Murmur.Group = Ice.createTempClass()
    class Group(object):
        '''A group. Groups are defined per channel, and can inherit members from parent channels.'''
        def __init__(self, name='', inherited=False, inherit=False, inheritable=False, add=None, remove=None, members=None):
            self.name = name
            self.inherited = inherited
            self.inherit = inherit
            self.inheritable = inheritable
            self.add = add
            self.remove = remove
            self.members = members

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.name)
            _h = 5 * _h + __builtin__.hash(self.inherited)
            _h = 5 * _h + __builtin__.hash(self.inherit)
            _h = 5 * _h + __builtin__.hash(self.inheritable)
            if self.add:
                for _i0 in self.add:
                    _h = 5 * _h + __builtin__.hash(_i0)
            if self.remove:
                for _i1 in self.remove:
                    _h = 5 * _h + __builtin__.hash(_i1)
            if self.members:
                for _i2 in self.members:
                    _h = 5 * _h + __builtin__.hash(_i2)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.Group):
                return self.name < other.name or self.inherited < other.inherited or self.inherit < other.inherit or self.inheritable < other.inheritable or self.add < other.add or self.remove < other.remove or self.members < other.members
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.Group):
                return self.name <= other.name or self.inherited <= other.inherited or self.inherit <= other.inherit or self.inheritable <= other.inheritable or self.add <= other.add or self.remove <= other.remove or self.members <= other.members
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.Group):
                return self.name == other.name and self.inherited == other.inherited and self.inherit == other.inherit and self.inheritable == other.inheritable and self.add == other.add and self.remove == other.remove and self.members == other.members
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.Group):
                return self.name != other.name or self.inherited != other.inherited or self.inherit != other.inherit or self.inheritable != other.inheritable or self.add != other.add or self.remove != other.remove or self.members != other.members
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.Group):
                return self.name > other.name or self.inherited > other.inherited or self.inherit > other.inherit or self.inheritable > other.inheritable or self.add > other.add or self.remove > other.remove or self.members > other.members
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.Group):
                return self.name >= other.name or self.inherited >= other.inherited or self.inherit >= other.inherit or self.inheritable >= other.inheritable or self.add >= other.add or self.remove >= other.remove or self.members >= other.members
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Group)

        __repr__ = __str__

    _M_Murmur._t_Group = IcePy.defineStruct('::Murmur::Group', Group, (), (
        ('name', (), IcePy._t_string),
        ('inherited', (), IcePy._t_bool),
        ('inherit', (), IcePy._t_bool),
        ('inheritable', (), IcePy._t_bool),
        ('add', (), _M_Murmur._t_IntList),
        ('remove', (), _M_Murmur._t_IntList),
        ('members', (), _M_Murmur._t_IntList)
    ))

    _M_Murmur.Group = Group
    del Group

_M_Murmur.PermissionWrite = 1

_M_Murmur.PermissionTraverse = 2

_M_Murmur.PermissionEnter = 4

_M_Murmur.PermissionSpeak = 8

_M_Murmur.PermissionWhisper = 256

_M_Murmur.PermissionMuteDeafen = 16

_M_Murmur.PermissionMove = 32

_M_Murmur.PermissionMakeChannel = 64

_M_Murmur.PermissionMakeTempChannel = 1024

_M_Murmur.PermissionLinkChannel = 128

_M_Murmur.PermissionTextMessage = 512

_M_Murmur.PermissionKick = 65536

_M_Murmur.PermissionBan = 131072

_M_Murmur.PermissionRegister = 262144

_M_Murmur.PermissionRegisterSelf = 524288

if not _M_Murmur.__dict__.has_key('ACL'):
    _M_Murmur.ACL = Ice.createTempClass()
    class ACL(object):
        '''Access Control List for a channel. ACLs are defined per channel, and can be inherited from parent channels.'''
        def __init__(self, applyHere=False, applySubs=False, inherited=False, userid=0, group='', allow=0, deny=0):
            self.applyHere = applyHere
            self.applySubs = applySubs
            self.inherited = inherited
            self.userid = userid
            self.group = group
            self.allow = allow
            self.deny = deny

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.applyHere)
            _h = 5 * _h + __builtin__.hash(self.applySubs)
            _h = 5 * _h + __builtin__.hash(self.inherited)
            _h = 5 * _h + __builtin__.hash(self.userid)
            _h = 5 * _h + __builtin__.hash(self.group)
            _h = 5 * _h + __builtin__.hash(self.allow)
            _h = 5 * _h + __builtin__.hash(self.deny)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.ACL):
                return self.applyHere < other.applyHere or self.applySubs < other.applySubs or self.inherited < other.inherited or self.userid < other.userid or self.group < other.group or self.allow < other.allow or self.deny < other.deny
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.ACL):
                return self.applyHere <= other.applyHere or self.applySubs <= other.applySubs or self.inherited <= other.inherited or self.userid <= other.userid or self.group <= other.group or self.allow <= other.allow or self.deny <= other.deny
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.ACL):
                return self.applyHere == other.applyHere and self.applySubs == other.applySubs and self.inherited == other.inherited and self.userid == other.userid and self.group == other.group and self.allow == other.allow and self.deny == other.deny
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.ACL):
                return self.applyHere != other.applyHere or self.applySubs != other.applySubs or self.inherited != other.inherited or self.userid != other.userid or self.group != other.group or self.allow != other.allow or self.deny != other.deny
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.ACL):
                return self.applyHere > other.applyHere or self.applySubs > other.applySubs or self.inherited > other.inherited or self.userid > other.userid or self.group > other.group or self.allow > other.allow or self.deny > other.deny
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.ACL):
                return self.applyHere >= other.applyHere or self.applySubs >= other.applySubs or self.inherited >= other.inherited or self.userid >= other.userid or self.group >= other.group or self.allow >= other.allow or self.deny >= other.deny
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ACL)

        __repr__ = __str__

    _M_Murmur._t_ACL = IcePy.defineStruct('::Murmur::ACL', ACL, (), (
        ('applyHere', (), IcePy._t_bool),
        ('applySubs', (), IcePy._t_bool),
        ('inherited', (), IcePy._t_bool),
        ('userid', (), IcePy._t_int),
        ('group', (), IcePy._t_string),
        ('allow', (), IcePy._t_int),
        ('deny', (), IcePy._t_int)
    ))

    _M_Murmur.ACL = ACL
    del ACL

if not _M_Murmur.__dict__.has_key('Ban'):
    _M_Murmur.Ban = Ice.createTempClass()
    class Ban(object):
        '''A single ip mask for a ban.'''
        def __init__(self, address=None, bits=0, name='', hash='', reason='', start=0, duration=0):
            self.address = address
            self.bits = bits
            self.name = name
            self.hash = hash
            self.reason = reason
            self.start = start
            self.duration = duration

        def __hash__(self):
            _h = 0
            if self.address:
                for _i0 in self.address:
                    _h = 5 * _h + __builtin__.hash(_i0)
            _h = 5 * _h + __builtin__.hash(self.bits)
            _h = 5 * _h + __builtin__.hash(self.name)
            _h = 5 * _h + __builtin__.hash(self.hash)
            _h = 5 * _h + __builtin__.hash(self.reason)
            _h = 5 * _h + __builtin__.hash(self.start)
            _h = 5 * _h + __builtin__.hash(self.duration)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.Ban):
                return self.address < other.address or self.bits < other.bits or self.name < other.name or self.hash < other.hash or self.reason < other.reason or self.start < other.start or self.duration < other.duration
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.Ban):
                return self.address <= other.address or self.bits <= other.bits or self.name <= other.name or self.hash <= other.hash or self.reason <= other.reason or self.start <= other.start or self.duration <= other.duration
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.Ban):
                return self.address == other.address and self.bits == other.bits and self.name == other.name and self.hash == other.hash and self.reason == other.reason and self.start == other.start and self.duration == other.duration
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.Ban):
                return self.address != other.address or self.bits != other.bits or self.name != other.name or self.hash != other.hash or self.reason != other.reason or self.start != other.start or self.duration != other.duration
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.Ban):
                return self.address > other.address or self.bits > other.bits or self.name > other.name or self.hash > other.hash or self.reason > other.reason or self.start > other.start or self.duration > other.duration
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.Ban):
                return self.address >= other.address or self.bits >= other.bits or self.name >= other.name or self.hash >= other.hash or self.reason >= other.reason or self.start >= other.start or self.duration >= other.duration
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Ban)

        __repr__ = __str__

    _M_Murmur._t_Ban = IcePy.defineStruct('::Murmur::Ban', Ban, (), (
        ('address', (), _M_Murmur._t_NetAddress),
        ('bits', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('hash', (), IcePy._t_string),
        ('reason', (), IcePy._t_string),
        ('start', (), IcePy._t_long),
        ('duration', (), IcePy._t_int)
    ))

    _M_Murmur.Ban = Ban
    del Ban

if not _M_Murmur.__dict__.has_key('LogEntry'):
    _M_Murmur.LogEntry = Ice.createTempClass()
    class LogEntry(object):
        '''A entry in the log.'''
        def __init__(self, timestamp=0, txt=''):
            self.timestamp = timestamp
            self.txt = txt

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.timestamp)
            _h = 5 * _h + __builtin__.hash(self.txt)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.LogEntry):
                return self.timestamp < other.timestamp or self.txt < other.txt
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.LogEntry):
                return self.timestamp <= other.timestamp or self.txt <= other.txt
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.LogEntry):
                return self.timestamp == other.timestamp and self.txt == other.txt
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.LogEntry):
                return self.timestamp != other.timestamp or self.txt != other.txt
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.LogEntry):
                return self.timestamp > other.timestamp or self.txt > other.txt
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.LogEntry):
                return self.timestamp >= other.timestamp or self.txt >= other.txt
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_LogEntry)

        __repr__ = __str__

    _M_Murmur._t_LogEntry = IcePy.defineStruct('::Murmur::LogEntry', LogEntry, (), (
        ('timestamp', (), IcePy._t_int),
        ('txt', (), IcePy._t_string)
    ))

    _M_Murmur.LogEntry = LogEntry
    del LogEntry

if not _M_Murmur.__dict__.has_key('Tree'):
    _M_Murmur._t_Tree = IcePy.declareClass('::Murmur::Tree')
    _M_Murmur._t_TreePrx = IcePy.declareProxy('::Murmur::Tree')

if not _M_Murmur.__dict__.has_key('_t_TreeList'):
    _M_Murmur._t_TreeList = IcePy.defineSequence('::Murmur::TreeList', (), _M_Murmur._t_Tree)

if not _M_Murmur.__dict__.has_key('ChannelInfo'):
    _M_Murmur.ChannelInfo = Ice.createTempClass()
    class ChannelInfo(object):

        def __init__(self, val):
            assert(val >= 0 and val < 2)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.ChannelInfo):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.ChannelInfo):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.ChannelInfo):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.ChannelInfo):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.ChannelInfo):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.ChannelInfo):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('ChannelDescription', 'ChannelPosition')

    ChannelInfo.ChannelDescription = ChannelInfo(0)
    ChannelInfo.ChannelPosition = ChannelInfo(1)

    _M_Murmur._t_ChannelInfo = IcePy.defineEnum('::Murmur::ChannelInfo', ChannelInfo, (), (ChannelInfo.ChannelDescription, ChannelInfo.ChannelPosition))

    _M_Murmur.ChannelInfo = ChannelInfo
    del ChannelInfo

if not _M_Murmur.__dict__.has_key('UserInfo'):
    _M_Murmur.UserInfo = Ice.createTempClass()
    class UserInfo(object):

        def __init__(self, val):
            assert(val >= 0 and val < 5)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_Murmur.UserInfo):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_Murmur.UserInfo):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_Murmur.UserInfo):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_Murmur.UserInfo):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_Murmur.UserInfo):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_Murmur.UserInfo):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('UserName', 'UserEmail', 'UserComment', 'UserHash', 'UserPassword')

    UserInfo.UserName = UserInfo(0)
    UserInfo.UserEmail = UserInfo(1)
    UserInfo.UserComment = UserInfo(2)
    UserInfo.UserHash = UserInfo(3)
    UserInfo.UserPassword = UserInfo(4)

    _M_Murmur._t_UserInfo = IcePy.defineEnum('::Murmur::UserInfo', UserInfo, (), (UserInfo.UserName, UserInfo.UserEmail, UserInfo.UserComment, UserInfo.UserHash, UserInfo.UserPassword))

    _M_Murmur.UserInfo = UserInfo
    del UserInfo

if not _M_Murmur.__dict__.has_key('_t_UserMap'):
    _M_Murmur._t_UserMap = IcePy.defineDictionary('::Murmur::UserMap', (), IcePy._t_int, _M_Murmur._t_User)

if not _M_Murmur.__dict__.has_key('_t_ChannelMap'):
    _M_Murmur._t_ChannelMap = IcePy.defineDictionary('::Murmur::ChannelMap', (), IcePy._t_int, _M_Murmur._t_Channel)

if not _M_Murmur.__dict__.has_key('_t_ChannelList'):
    _M_Murmur._t_ChannelList = IcePy.defineSequence('::Murmur::ChannelList', (), _M_Murmur._t_Channel)

if not _M_Murmur.__dict__.has_key('_t_UserList'):
    _M_Murmur._t_UserList = IcePy.defineSequence('::Murmur::UserList', (), _M_Murmur._t_User)

if not _M_Murmur.__dict__.has_key('_t_GroupList'):
    _M_Murmur._t_GroupList = IcePy.defineSequence('::Murmur::GroupList', (), _M_Murmur._t_Group)

if not _M_Murmur.__dict__.has_key('_t_ACLList'):
    _M_Murmur._t_ACLList = IcePy.defineSequence('::Murmur::ACLList', (), _M_Murmur._t_ACL)

if not _M_Murmur.__dict__.has_key('_t_LogList'):
    _M_Murmur._t_LogList = IcePy.defineSequence('::Murmur::LogList', (), _M_Murmur._t_LogEntry)

if not _M_Murmur.__dict__.has_key('_t_BanList'):
    _M_Murmur._t_BanList = IcePy.defineSequence('::Murmur::BanList', (), _M_Murmur._t_Ban)

if not _M_Murmur.__dict__.has_key('_t_IdList'):
    _M_Murmur._t_IdList = IcePy.defineSequence('::Murmur::IdList', (), IcePy._t_int)

if not _M_Murmur.__dict__.has_key('_t_NameList'):
    _M_Murmur._t_NameList = IcePy.defineSequence('::Murmur::NameList', (), IcePy._t_string)

if not _M_Murmur.__dict__.has_key('_t_NameMap'):
    _M_Murmur._t_NameMap = IcePy.defineDictionary('::Murmur::NameMap', (), IcePy._t_int, IcePy._t_string)

if not _M_Murmur.__dict__.has_key('_t_IdMap'):
    _M_Murmur._t_IdMap = IcePy.defineDictionary('::Murmur::IdMap', (), IcePy._t_string, IcePy._t_int)

if not _M_Murmur.__dict__.has_key('_t_Texture'):
    _M_Murmur._t_Texture = IcePy.defineSequence('::Murmur::Texture', (), IcePy._t_byte)

if not _M_Murmur.__dict__.has_key('_t_ConfigMap'):
    _M_Murmur._t_ConfigMap = IcePy.defineDictionary('::Murmur::ConfigMap', (), IcePy._t_string, IcePy._t_string)

if not _M_Murmur.__dict__.has_key('_t_GroupNameList'):
    _M_Murmur._t_GroupNameList = IcePy.defineSequence('::Murmur::GroupNameList', (), IcePy._t_string)

if not _M_Murmur.__dict__.has_key('_t_CertificateDer'):
    _M_Murmur._t_CertificateDer = IcePy.defineSequence('::Murmur::CertificateDer', (), IcePy._t_byte)

if not _M_Murmur.__dict__.has_key('_t_CertificateList'):
    _M_Murmur._t_CertificateList = IcePy.defineSequence('::Murmur::CertificateList', (), _M_Murmur._t_CertificateDer)

if not _M_Murmur.__dict__.has_key('_t_UserInfoMap'):
    _M_Murmur._t_UserInfoMap = IcePy.defineDictionary('::Murmur::UserInfoMap', (), _M_Murmur._t_UserInfo, IcePy._t_string)

if not _M_Murmur.__dict__.has_key('Tree'):
    _M_Murmur.Tree = Ice.createTempClass()
    class Tree(Ice.Object):
        '''User and subchannel state. Read-only.'''
        def __init__(self, c=Ice._struct_marker, children=None, users=None):
            if c is Ice._struct_marker:
                self.c = _M_Murmur.Channel()
            else:
                self.c = c
            self.children = children
            self.users = users

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Tree')

        def ice_id(self, current=None):
            return '::Murmur::Tree'

        def ice_staticId():
            return '::Murmur::Tree'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Tree)

        __repr__ = __str__

    _M_Murmur.TreePrx = Ice.createTempClass()
    class TreePrx(Ice.ObjectPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.TreePrx.ice_checkedCast(proxy, '::Murmur::Tree', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.TreePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_TreePrx = IcePy.defineProxy('::Murmur::Tree', TreePrx)

    _M_Murmur._t_Tree = IcePy.defineClass('::Murmur::Tree', Tree, (), False, None, (), (
        ('c', (), _M_Murmur._t_Channel),
        ('children', (), _M_Murmur._t_TreeList),
        ('users', (), _M_Murmur._t_UserList)
    ))
    Tree._ice_type = _M_Murmur._t_Tree

    _M_Murmur.Tree = Tree
    del Tree

    _M_Murmur.TreePrx = TreePrx
    del TreePrx

if not _M_Murmur.__dict__.has_key('MurmurException'):
    _M_Murmur.MurmurException = Ice.createTempClass()
    class MurmurException(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::MurmurException'

    _M_Murmur._t_MurmurException = IcePy.defineException('::Murmur::MurmurException', MurmurException, (), None, ())
    MurmurException._ice_type = _M_Murmur._t_MurmurException

    _M_Murmur.MurmurException = MurmurException
    del MurmurException

if not _M_Murmur.__dict__.has_key('InvalidSessionException'):
    _M_Murmur.InvalidSessionException = Ice.createTempClass()
    class InvalidSessionException(_M_Murmur.MurmurException):
        '''This is thrown when you specify an invalid session. This may happen if the user has disconnected since your last call to [Server::getUsers]. See [User::session]'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidSessionException'

    _M_Murmur._t_InvalidSessionException = IcePy.defineException('::Murmur::InvalidSessionException', InvalidSessionException, (), _M_Murmur._t_MurmurException, ())
    InvalidSessionException._ice_type = _M_Murmur._t_InvalidSessionException

    _M_Murmur.InvalidSessionException = InvalidSessionException
    del InvalidSessionException

if not _M_Murmur.__dict__.has_key('InvalidChannelException'):
    _M_Murmur.InvalidChannelException = Ice.createTempClass()
    class InvalidChannelException(_M_Murmur.MurmurException):
        '''This is thrown when you specify an invalid channel id. This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidChannelException'

    _M_Murmur._t_InvalidChannelException = IcePy.defineException('::Murmur::InvalidChannelException', InvalidChannelException, (), _M_Murmur._t_MurmurException, ())
    InvalidChannelException._ice_type = _M_Murmur._t_InvalidChannelException

    _M_Murmur.InvalidChannelException = InvalidChannelException
    del InvalidChannelException

if not _M_Murmur.__dict__.has_key('InvalidServerException'):
    _M_Murmur.InvalidServerException = Ice.createTempClass()
    class InvalidServerException(_M_Murmur.MurmurException):
        '''This is thrown when you try to do an operation on a server that does not exist. This may happen if someone has removed the server.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidServerException'

    _M_Murmur._t_InvalidServerException = IcePy.defineException('::Murmur::InvalidServerException', InvalidServerException, (), _M_Murmur._t_MurmurException, ())
    InvalidServerException._ice_type = _M_Murmur._t_InvalidServerException

    _M_Murmur.InvalidServerException = InvalidServerException
    del InvalidServerException

if not _M_Murmur.__dict__.has_key('ServerBootedException'):
    _M_Murmur.ServerBootedException = Ice.createTempClass()
    class ServerBootedException(_M_Murmur.MurmurException):
        '''This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::ServerBootedException'

    _M_Murmur._t_ServerBootedException = IcePy.defineException('::Murmur::ServerBootedException', ServerBootedException, (), _M_Murmur._t_MurmurException, ())
    ServerBootedException._ice_type = _M_Murmur._t_ServerBootedException

    _M_Murmur.ServerBootedException = ServerBootedException
    del ServerBootedException

if not _M_Murmur.__dict__.has_key('ServerFailureException'):
    _M_Murmur.ServerFailureException = Ice.createTempClass()
    class ServerFailureException(_M_Murmur.MurmurException):
        '''This is thrown if [Server::start] fails, and should generally be the cause for some concern.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::ServerFailureException'

    _M_Murmur._t_ServerFailureException = IcePy.defineException('::Murmur::ServerFailureException', ServerFailureException, (), _M_Murmur._t_MurmurException, ())
    ServerFailureException._ice_type = _M_Murmur._t_ServerFailureException

    _M_Murmur.ServerFailureException = ServerFailureException
    del ServerFailureException

if not _M_Murmur.__dict__.has_key('InvalidUserException'):
    _M_Murmur.InvalidUserException = Ice.createTempClass()
    class InvalidUserException(_M_Murmur.MurmurException):
        '''This is thrown when you specify an invalid userid.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidUserException'

    _M_Murmur._t_InvalidUserException = IcePy.defineException('::Murmur::InvalidUserException', InvalidUserException, (), _M_Murmur._t_MurmurException, ())
    InvalidUserException._ice_type = _M_Murmur._t_InvalidUserException

    _M_Murmur.InvalidUserException = InvalidUserException
    del InvalidUserException

if not _M_Murmur.__dict__.has_key('InvalidTextureException'):
    _M_Murmur.InvalidTextureException = Ice.createTempClass()
    class InvalidTextureException(_M_Murmur.MurmurException):
        '''This is thrown when you try to set an invalid texture.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidTextureException'

    _M_Murmur._t_InvalidTextureException = IcePy.defineException('::Murmur::InvalidTextureException', InvalidTextureException, (), _M_Murmur._t_MurmurException, ())
    InvalidTextureException._ice_type = _M_Murmur._t_InvalidTextureException

    _M_Murmur.InvalidTextureException = InvalidTextureException
    del InvalidTextureException

if not _M_Murmur.__dict__.has_key('InvalidCallbackException'):
    _M_Murmur.InvalidCallbackException = Ice.createTempClass()
    class InvalidCallbackException(_M_Murmur.MurmurException):
        '''This is thrown when you supply an invalid callback.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidCallbackException'

    _M_Murmur._t_InvalidCallbackException = IcePy.defineException('::Murmur::InvalidCallbackException', InvalidCallbackException, (), _M_Murmur._t_MurmurException, ())
    InvalidCallbackException._ice_type = _M_Murmur._t_InvalidCallbackException

    _M_Murmur.InvalidCallbackException = InvalidCallbackException
    del InvalidCallbackException

if not _M_Murmur.__dict__.has_key('InvalidSecretException'):
    _M_Murmur.InvalidSecretException = Ice.createTempClass()
    class InvalidSecretException(_M_Murmur.MurmurException):
        '''This is thrown when you supply the wrong secret in the calling context.'''
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'Murmur::InvalidSecretException'

    _M_Murmur._t_InvalidSecretException = IcePy.defineException('::Murmur::InvalidSecretException', InvalidSecretException, (), _M_Murmur._t_MurmurException, ())
    InvalidSecretException._ice_type = _M_Murmur._t_InvalidSecretException

    _M_Murmur.InvalidSecretException = InvalidSecretException
    del InvalidSecretException

if not _M_Murmur.__dict__.has_key('ServerCallback'):
    _M_Murmur.ServerCallback = Ice.createTempClass()
    class ServerCallback(Ice.Object):
        '''Callback interface for servers. You can supply an implementation of this to receive notification
messages from the server.
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
complete before continuing processing.
Note that callbacks are removed when a server is stopped, so you should have a callback for
[MetaCallback::started] which calls [Server::addCallback].'''
        def __init__(self):
            if __builtin__.type(self) == _M_Murmur.ServerCallback:
                raise RuntimeError('Murmur.ServerCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerCallback')

        def ice_id(self, current=None):
            return '::Murmur::ServerCallback'

        def ice_staticId():
            return '::Murmur::ServerCallback'
        ice_staticId = staticmethod(ice_staticId)

        def userConnected(self, state, current=None):
            '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
            pass

        def userDisconnected(self, state, current=None):
            '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like [Server::getState]
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
            pass

        def userStateChanged(self, state, current=None):
            '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
            pass

        def channelCreated(self, state, current=None):
            '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
            pass

        def channelRemoved(self, state, current=None):
            '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like [Server::getChannelState]
Arguments:
    state State of removed channel.'''
            pass

        def channelStateChanged(self, state, current=None):
            '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerCallback)

        __repr__ = __str__

    _M_Murmur.ServerCallbackPrx = Ice.createTempClass()
    class ServerCallbackPrx(Ice.ObjectPrx):

        '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
        def userConnected(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_userConnected.invoke(self, ((state, ), _ctx))

        '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
        def begin_userConnected(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_userConnected.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a user connects to the server. 
Arguments:
    state State of connected user.'''
        def end_userConnected(self, _r):
            return _M_Murmur.ServerCallback._op_userConnected.end(self, _r)

        '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like [Server::getState]
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
        def userDisconnected(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_userDisconnected.invoke(self, ((state, ), _ctx))

        '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like [Server::getState]
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
        def begin_userDisconnected(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_userDisconnected.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like [Server::getState]
to retrieve the user's state.
Arguments:
    state State of disconnected user.'''
        def end_userDisconnected(self, _r):
            return _M_Murmur.ServerCallback._op_userDisconnected.end(self, _r)

        '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
        def userStateChanged(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_userStateChanged.invoke(self, ((state, ), _ctx))

        '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
        def begin_userStateChanged(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_userStateChanged.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
Arguments:
    state New state of user.'''
        def end_userStateChanged(self, _r):
            return _M_Murmur.ServerCallback._op_userStateChanged.end(self, _r)

        '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
        def channelCreated(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelCreated.invoke(self, ((state, ), _ctx))

        '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
        def begin_channelCreated(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelCreated.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a new channel is created. 
Arguments:
    state State of new channel.'''
        def end_channelCreated(self, _r):
            return _M_Murmur.ServerCallback._op_channelCreated.end(self, _r)

        '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like [Server::getChannelState]
Arguments:
    state State of removed channel.'''
        def channelRemoved(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelRemoved.invoke(self, ((state, ), _ctx))

        '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like [Server::getChannelState]
Arguments:
    state State of removed channel.'''
        def begin_channelRemoved(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelRemoved.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a channel is removed. The channel has already been removed, you can no longer use methods like [Server::getChannelState]
Arguments:
    state State of removed channel.'''
        def end_channelRemoved(self, _r):
            return _M_Murmur.ServerCallback._op_channelRemoved.end(self, _r)

        '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
        def channelStateChanged(self, state, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelStateChanged.invoke(self, ((state, ), _ctx))

        '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
        def begin_channelStateChanged(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerCallback._op_channelStateChanged.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
Arguments:
    state New state of channel.'''
        def end_channelStateChanged(self, _r):
            return _M_Murmur.ServerCallback._op_channelStateChanged.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerCallbackPrx.ice_checkedCast(proxy, '::Murmur::ServerCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_ServerCallbackPrx = IcePy.defineProxy('::Murmur::ServerCallback', ServerCallbackPrx)

    _M_Murmur._t_ServerCallback = IcePy.defineClass('::Murmur::ServerCallback', ServerCallback, (), True, None, (), ())
    ServerCallback._ice_type = _M_Murmur._t_ServerCallback

    ServerCallback._op_userConnected = IcePy.Operation('userConnected', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), _M_Murmur._t_User),), (), None, ())
    ServerCallback._op_userDisconnected = IcePy.Operation('userDisconnected', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), _M_Murmur._t_User),), (), None, ())
    ServerCallback._op_userStateChanged = IcePy.Operation('userStateChanged', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), _M_Murmur._t_User),), (), None, ())
    ServerCallback._op_channelCreated = IcePy.Operation('channelCreated', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), _M_Murmur._t_Channel),), (), None, ())
    ServerCallback._op_channelRemoved = IcePy.Operation('channelRemoved', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), _M_Murmur._t_Channel),), (), None, ())
    ServerCallback._op_channelStateChanged = IcePy.Operation('channelStateChanged', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), _M_Murmur._t_Channel),), (), None, ())

    _M_Murmur.ServerCallback = ServerCallback
    del ServerCallback

    _M_Murmur.ServerCallbackPrx = ServerCallbackPrx
    del ServerCallbackPrx

_M_Murmur.ContextServer = 1

_M_Murmur.ContextChannel = 2

_M_Murmur.ContextUser = 4

if not _M_Murmur.__dict__.has_key('ServerContextCallback'):
    _M_Murmur.ServerContextCallback = Ice.createTempClass()
    class ServerContextCallback(Ice.Object):
        '''Callback interface for context actions. You need to supply one of these for [Server::addContext]. 
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
complete before continuing processing.'''
        def __init__(self):
            if __builtin__.type(self) == _M_Murmur.ServerContextCallback:
                raise RuntimeError('Murmur.ServerContextCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerContextCallback')

        def ice_id(self, current=None):
            return '::Murmur::ServerContextCallback'

        def ice_staticId():
            return '::Murmur::ServerContextCallback'
        ice_staticId = staticmethod(ice_staticId)

        def contextAction(self, action, usr, session, channelid, current=None):
            '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerContextCallback)

        __repr__ = __str__

    _M_Murmur.ServerContextCallbackPrx = Ice.createTempClass()
    class ServerContextCallbackPrx(Ice.ObjectPrx):

        '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
        def contextAction(self, action, usr, session, channelid, _ctx=None):
            return _M_Murmur.ServerContextCallback._op_contextAction.invoke(self, ((action, usr, session, channelid), _ctx))

        '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
        def begin_contextAction(self, action, usr, session, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerContextCallback._op_contextAction.begin(self, ((action, usr, session, channelid), _response, _ex, _sent, _ctx))

        '''Called when a context action is performed.
Arguments:
    action Action to be performed.
    usr User which initiated the action.
    session If nonzero, session of target user.
    channelid If nonzero, session of target channel.'''
        def end_contextAction(self, _r):
            return _M_Murmur.ServerContextCallback._op_contextAction.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerContextCallbackPrx.ice_checkedCast(proxy, '::Murmur::ServerContextCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerContextCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_ServerContextCallbackPrx = IcePy.defineProxy('::Murmur::ServerContextCallback', ServerContextCallbackPrx)

    _M_Murmur._t_ServerContextCallback = IcePy.defineClass('::Murmur::ServerContextCallback', ServerContextCallback, (), True, None, (), ())
    ServerContextCallback._ice_type = _M_Murmur._t_ServerContextCallback

    ServerContextCallback._op_contextAction = IcePy.Operation('contextAction', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string), ((), _M_Murmur._t_User), ((), IcePy._t_int), ((), IcePy._t_int)), (), None, ())

    _M_Murmur.ServerContextCallback = ServerContextCallback
    del ServerContextCallback

    _M_Murmur.ServerContextCallbackPrx = ServerContextCallbackPrx
    del ServerContextCallbackPrx

if not _M_Murmur.__dict__.has_key('ServerAuthenticator'):
    _M_Murmur.ServerAuthenticator = Ice.createTempClass()
    class ServerAuthenticator(Ice.Object):
        '''Callback interface for server authentication. You need to supply one of these for [Server::setAuthenticator].
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that unlike [ServerCallback] and [ServerContextCallback], these methods are called
synchronously. If the response lags, the entire murmur server will lag.
Also note that, as the method calls are synchronous, making a call to [Server] or [Meta] will
deadlock the server.'''
        def __init__(self):
            if __builtin__.type(self) == _M_Murmur.ServerAuthenticator:
                raise RuntimeError('Murmur.ServerAuthenticator is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerAuthenticator')

        def ice_id(self, current=None):
            return '::Murmur::ServerAuthenticator'

        def ice_staticId():
            return '::Murmur::ServerAuthenticator'
        ice_staticId = staticmethod(ice_staticId)

        def authenticate(self, name, pw, certificates, certhash, certstrong, current=None):
            '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
            pass

        def getInfo(self, id, current=None):
            '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    key Key of information to be retrieved.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
            pass

        def nameToId(self, name, current=None):
            '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
            pass

        def idToName(self, id, current=None):
            '''Map a user to a User id.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
            pass

        def idToTexture(self, id, current=None):
            '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerAuthenticator)

        __repr__ = __str__

    _M_Murmur.ServerAuthenticatorPrx = Ice.createTempClass()
    class ServerAuthenticatorPrx(Ice.ObjectPrx):

        '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
        def authenticate(self, name, pw, certificates, certhash, certstrong, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_authenticate.invoke(self, ((name, pw, certificates, certhash, certstrong), _ctx))

        '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
        def begin_authenticate(self, name, pw, certificates, certhash, certstrong, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_authenticate.begin(self, ((name, pw, certificates, certhash, certstrong), _response, _ex, _sent, _ctx))

        '''Called to authenticate a user. If you do not know the username in question, always return -2 from this
method to fall through to normal database authentication.
Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
the username and id so it cannot be used for normal database authentication.
The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
should only be trusted if certstrong is true.

Arguments:
    name Username to authenticate.
    pw Password to authenticate with.
    certificates List of der encoded certificates the user connected with.
    certhash Hash of user certificate, as used by murmur internally when matching.
    certstrong True if certificate was valid and signed by a trusted CA.
    newname Set this to change the username from the supplied one.
    groups List of groups on the root channel that the user will be added to for the duration of the connection.
Returns:
    UserID of authenticated user, -1 for authentication failures and -2 for unknown user (fallthrough).'''
        def end_authenticate(self, _r):
            return _M_Murmur.ServerAuthenticator._op_authenticate.end(self, _r)

        '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    key Key of information to be retrieved.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
        def getInfo(self, id, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_getInfo.invoke(self, ((id, ), _ctx))

        '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    key Key of information to be retrieved.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
        def begin_getInfo(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_getInfo.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
want murmur to take care of this information itself, simply return false to fall through.
Arguments:
    id User id.
    key Key of information to be retrieved.
    info Information about user. This needs to include at least "name".
Returns:
    true if information is present, false to fall through.'''
        def end_getInfo(self, _r):
            return _M_Murmur.ServerAuthenticator._op_getInfo.end(self, _r)

        '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
        def nameToId(self, name, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_nameToId.invoke(self, ((name, ), _ctx))

        '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
        def begin_nameToId(self, name, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_nameToId.begin(self, ((name, ), _response, _ex, _sent, _ctx))

        '''Map a name to a user id.
Arguments:
    name Username to map.
Returns:
    User id or -2 for unknown name.'''
        def end_nameToId(self, _r):
            return _M_Murmur.ServerAuthenticator._op_nameToId.end(self, _r)

        '''Map a user to a User id.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
        def idToName(self, id, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToName.invoke(self, ((id, ), _ctx))

        '''Map a user to a User id.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
        def begin_idToName(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToName.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Map a user to a User id.
Arguments:
    id User id to map.
Returns:
    Name of user or empty string for unknown id.'''
        def end_idToName(self, _r):
            return _M_Murmur.ServerAuthenticator._op_idToName.end(self, _r)

        '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
        def idToTexture(self, id, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.invoke(self, ((id, ), _ctx))

        '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
        def begin_idToTexture(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Map a user to a custom Texture.
Arguments:
    id User id to map.
Returns:
    User texture or an empty texture for unknwon users or users without textures.'''
        def end_idToTexture(self, _r):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerAuthenticatorPrx.ice_checkedCast(proxy, '::Murmur::ServerAuthenticator', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerAuthenticatorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_ServerAuthenticatorPrx = IcePy.defineProxy('::Murmur::ServerAuthenticator', ServerAuthenticatorPrx)

    _M_Murmur._t_ServerAuthenticator = IcePy.defineClass('::Murmur::ServerAuthenticator', ServerAuthenticator, (), True, None, (), ())
    ServerAuthenticator._ice_type = _M_Murmur._t_ServerAuthenticator

    ServerAuthenticator._op_authenticate = IcePy.Operation('authenticate', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string), ((), IcePy._t_string), ((), _M_Murmur._t_CertificateList), ((), IcePy._t_string), ((), IcePy._t_bool)), (((), IcePy._t_string), ((), _M_Murmur._t_GroupNameList)), IcePy._t_int, ())
    ServerAuthenticator._op_getInfo = IcePy.Operation('getInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_int),), (((), _M_Murmur._t_UserInfoMap),), IcePy._t_bool, ())
    ServerAuthenticator._op_nameToId = IcePy.Operation('nameToId', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())
    ServerAuthenticator._op_idToName = IcePy.Operation('idToName', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_int),), (), IcePy._t_string, ())
    ServerAuthenticator._op_idToTexture = IcePy.Operation('idToTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_int),), (), _M_Murmur._t_Texture, ())

    _M_Murmur.ServerAuthenticator = ServerAuthenticator
    del ServerAuthenticator

    _M_Murmur.ServerAuthenticatorPrx = ServerAuthenticatorPrx
    del ServerAuthenticatorPrx

if not _M_Murmur.__dict__.has_key('ServerUpdatingAuthenticator'):
    _M_Murmur.ServerUpdatingAuthenticator = Ice.createTempClass()
    class ServerUpdatingAuthenticator(_M_Murmur.ServerAuthenticator):
        '''Callback interface for server authentication and registration. This allows you to support both authentication
and account updating.
You do not need to implement this if all you want is authentication, you only need this if other scripts
connected to the same server calls e.g. [Server::setTexture].
Almost all of these methods support fall through, meaning murmur should continue the operation against its
own database.'''
        def __init__(self):
            if __builtin__.type(self) == _M_Murmur.ServerUpdatingAuthenticator:
                raise RuntimeError('Murmur.ServerUpdatingAuthenticator is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerAuthenticator', '::Murmur::ServerUpdatingAuthenticator')

        def ice_id(self, current=None):
            return '::Murmur::ServerUpdatingAuthenticator'

        def ice_staticId():
            return '::Murmur::ServerUpdatingAuthenticator'
        ice_staticId = staticmethod(ice_staticId)

        def registerUser(self, info, current=None):
            '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
            pass

        def unregisterUser(self, id, current=None):
            '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
            pass

        def getRegisteredUsers(self, filter, current=None):
            '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
            pass

        def setInfo(self, id, info, current=None):
            '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
            pass

        def setTexture(self, id, tex, current=None):
            '''Set texture of user registration.
Arguments:
    id Userid of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerUpdatingAuthenticator)

        __repr__ = __str__

    _M_Murmur.ServerUpdatingAuthenticatorPrx = Ice.createTempClass()
    class ServerUpdatingAuthenticatorPrx(_M_Murmur.ServerAuthenticatorPrx):

        '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
        def registerUser(self, info, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.invoke(self, ((info, ), _ctx))

        '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
        def begin_registerUser(self, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.begin(self, ((info, ), _response, _ex, _sent, _ctx))

        '''Register a new user.
Arguments:
    info Information about user to register.
Returns:
    User id of new user, -1 for registration failure, or -2 to fall through.'''
        def end_registerUser(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.end(self, _r)

        '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
        def unregisterUser(self, id, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.invoke(self, ((id, ), _ctx))

        '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
        def begin_unregisterUser(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Unregister a user.
Arguments:
    id Userid to unregister.
Returns:
    1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.'''
        def end_unregisterUser(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.end(self, _r)

        '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
        def getRegisteredUsers(self, filter, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.invoke(self, ((filter, ), _ctx))

        '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
        def begin_getRegisteredUsers(self, filter, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.begin(self, ((filter, ), _response, _ex, _sent, _ctx))

        '''Get a list of registered users matching filter.
Arguments:
    filter Substring usernames must contain. If empty, return all registered users.
Returns:
    List of matching registered users.'''
        def end_getRegisteredUsers(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.end(self, _r)

        '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def setInfo(self, id, info, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.invoke(self, ((id, info), _ctx))

        '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def begin_setInfo(self, id, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.begin(self, ((id, info), _response, _ex, _sent, _ctx))

        '''Set additional information for user registration.
Arguments:
    id Userid of registered user.
    info Information to set about user. This should be merged with existing information.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def end_setInfo(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.end(self, _r)

        '''Set texture of user registration.
Arguments:
    id Userid of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def setTexture(self, id, tex, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.invoke(self, ((id, tex), _ctx))

        '''Set texture of user registration.
Arguments:
    id Userid of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def begin_setTexture(self, id, tex, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.begin(self, ((id, tex), _response, _ex, _sent, _ctx))

        '''Set texture of user registration.
Arguments:
    id Userid of registered user.
    tex New texture.
Returns:
    1 for successfull update, 0 for unsuccessfull update, -1 to fall through.'''
        def end_setTexture(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerUpdatingAuthenticatorPrx.ice_checkedCast(proxy, '::Murmur::ServerUpdatingAuthenticator', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerUpdatingAuthenticatorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_ServerUpdatingAuthenticatorPrx = IcePy.defineProxy('::Murmur::ServerUpdatingAuthenticator', ServerUpdatingAuthenticatorPrx)

    _M_Murmur._t_ServerUpdatingAuthenticator = IcePy.defineClass('::Murmur::ServerUpdatingAuthenticator', ServerUpdatingAuthenticator, (), True, None, (_M_Murmur._t_ServerAuthenticator,), ())
    ServerUpdatingAuthenticator._ice_type = _M_Murmur._t_ServerUpdatingAuthenticator

    ServerUpdatingAuthenticator._op_registerUser = IcePy.Operation('registerUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), _M_Murmur._t_UserInfoMap),), (), IcePy._t_int, ())
    ServerUpdatingAuthenticator._op_unregisterUser = IcePy.Operation('unregisterUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_int),), (), IcePy._t_int, ())
    ServerUpdatingAuthenticator._op_getRegisteredUsers = IcePy.Operation('getRegisteredUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), _M_Murmur._t_NameMap, ())
    ServerUpdatingAuthenticator._op_setInfo = IcePy.Operation('setInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_int), ((), _M_Murmur._t_UserInfoMap)), (), IcePy._t_int, ())
    ServerUpdatingAuthenticator._op_setTexture = IcePy.Operation('setTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_int), ((), _M_Murmur._t_Texture)), (), IcePy._t_int, ())

    _M_Murmur.ServerUpdatingAuthenticator = ServerUpdatingAuthenticator
    del ServerUpdatingAuthenticator

    _M_Murmur.ServerUpdatingAuthenticatorPrx = ServerUpdatingAuthenticatorPrx
    del ServerUpdatingAuthenticatorPrx

if not _M_Murmur.__dict__.has_key('Server'):
    _M_Murmur.Server = Ice.createTempClass()
    class Server(Ice.Object):
        '''Per-server interface. This includes all methods for configuring and altering
the state of a single virtual server. You can retrieve a pointer to this interface
from one of the methods in [Meta].'''
        def __init__(self):
            if __builtin__.type(self) == _M_Murmur.Server:
                raise RuntimeError('Murmur.Server is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Server')

        def ice_id(self, current=None):
            return '::Murmur::Server'

        def ice_staticId():
            return '::Murmur::Server'
        ice_staticId = staticmethod(ice_staticId)

        def isRunning_async(self, _cb, current=None):
            '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
            pass

        def start_async(self, _cb, current=None):
            '''Start server.'''
            pass

        def stop_async(self, _cb, current=None):
            '''Stop server.'''
            pass

        def delete_async(self, _cb, current=None):
            '''Delete server and all it's configuration.'''
            pass

        def id_async(self, _cb, current=None):
            '''Fetch the server id.

Returns:
    Unique server id.'''
            pass

        def addCallback_async(self, _cb, cb, current=None):
            '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
            pass

        def removeCallback_async(self, _cb, cb, current=None):
            '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
            pass

        def setAuthenticator_async(self, _cb, auth, current=None):
            '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
            pass

        def getConf_async(self, _cb, key, current=None):
            '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see [Meta::getDefaultConf]'''
            pass

        def getAllConf_async(self, _cb, current=None):
            '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from [Meta::getDefaultConf] is used.'''
            pass

        def setConf_async(self, _cb, key, value, current=None):
            '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
            pass

        def setSuperuserPassword_async(self, _cb, pw, current=None):
            '''Set superuser password. This is just a convenience for using [updateRegistration] on user id 0.
Arguments:
    pw Password.'''
            pass

        def getLog_async(self, _cb, first, last, current=None):
            '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
            pass

        def getUsers_async(self, _cb, current=None):
            '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
            pass

        def getChannels_async(self, _cb, current=None):
            '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
            pass

        def getCertificateList_async(self, _cb, session, current=None):
            '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    Certificate list of user.'''
            pass

        def getTree_async(self, _cb, current=None):
            '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
            pass

        def getBans_async(self, _cb, current=None):
            '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
            pass

        def setBans_async(self, _cb, bans, current=None):
            '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call [getBans] and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
            pass

        def kickUser_async(self, _cb, session, reason, current=None):
            '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See [User::session].
    reason Text message to show when user is kicked.'''
            pass

        def getState_async(self, _cb, session, current=None):
            '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    State of connected user.'''
            pass

        def setState_async(self, _cb, state, current=None):
            '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
            pass

        def sendMessage_async(self, _cb, session, text, current=None):
            '''Send text message to a single user.
Arguments:
    session Connection ID of user. See [User::session].
    text Message to send.'''
            pass

        def hasPermission_async(self, _cb, session, channelid, perm, current=None):
            '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See [User::session].
    channelid ID of Channel. See [Channel::id].
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
            pass

        def addContextCallback_async(self, _cb, session, action, text, cb, ctx, current=None):
            '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of [ContextServer], [ContextChannel] and [ContextUser].'''
            pass

        def removeContextCallback_async(self, _cb, cb, current=None):
            '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
            pass

        def getChannelState_async(self, _cb, channelid, current=None):
            '''Get state of single channel.
Arguments:
    channelid ID of Channel. See [Channel::id].
Returns:
    State of channel.'''
            pass

        def setChannelState_async(self, _cb, state, current=None):
            '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
            pass

        def removeChannel_async(self, _cb, channelid, current=None):
            '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See [Channel::id].'''
            pass

        def addChannel_async(self, _cb, name, parent, current=None):
            '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See [Channel::id].
Returns:
    ID of newly created channel.'''
            pass

        def sendMessageChannel_async(self, _cb, channelid, tree, text, current=None):
            '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See [Channel::id].
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
            pass

        def getACL_async(self, _cb, channelid, current=None):
            '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
            pass

        def setACL_async(self, _cb, channelid, acls, groups, inherit, current=None):
            '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
            pass

        def addUserToGroup_async(self, _cb, channelid, session, group, current=None):
            '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to add to.'''
            pass

        def removeUserFromGroup_async(self, _cb, channelid, session, group, current=None):
            '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to remove from.'''
            pass

        def redirectWhisperGroup_async(self, _cb, session, source, target, current=None):
            '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See [User::session].
    source Group name to redirect from.
    target Group name to redirect to.'''
            pass

        def getUserNames_async(self, _cb, ids, current=None):
            '''Map a list of [User::userid] to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
            pass

        def getUserIds_async(self, _cb, names, current=None):
            '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
            pass

        def registerUser_async(self, _cb, info, current=None):
            '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See [RegisteredUser::userid].'''
            pass

        def unregisterUser_async(self, _cb, userid, current=None):
            '''Remove a user registration.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].'''
            pass

        def updateRegistration_async(self, _cb, userid, info, current=None):
            '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
            pass

        def getRegistration_async(self, _cb, userid, current=None):
            '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Registration record.'''
            pass

        def getRegisteredUsers_async(self, _cb, filter, current=None):
            '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
            pass

        def verifyPassword_async(self, _cb, name, pw, current=None):
            '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See [RegisteredUser::name].
    pw User password.
Returns:
    User ID of registered user (See [RegisteredUser::userid]), -1 for failed authentication or -2 for unknown usernames.'''
            pass

        def getTexture_async(self, _cb, userid, current=None):
            '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Custom texture associated with user or an empty texture.'''
            pass

        def setTexture_async(self, _cb, userid, tex, current=None):
            '''Set user texture. The texture is a 600x60 32-bit BGRA raw texture, optionally zlib compress()ed.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
    tex Texture to set for the user, or an empty texture to remove the existing texture.'''
            pass

        def getUptime_async(self, _cb, current=None):
            '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Server)

        __repr__ = __str__

    _M_Murmur.ServerPrx = Ice.createTempClass()
    class ServerPrx(Ice.ObjectPrx):

        '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
        def isRunning(self, _ctx=None):
            return _M_Murmur.Server._op_isRunning.invoke(self, ((), _ctx))

        '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
        def begin_isRunning(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_isRunning.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Shows if the server currently running (accepting users).

Returns:
    Run-state of server.'''
        def end_isRunning(self, _r):
            return _M_Murmur.Server._op_isRunning.end(self, _r)

        '''Start server.'''
        def start(self, _ctx=None):
            return _M_Murmur.Server._op_start.invoke(self, ((), _ctx))

        '''Start server.'''
        def begin_start(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_start.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Start server.'''
        def end_start(self, _r):
            return _M_Murmur.Server._op_start.end(self, _r)

        '''Stop server.'''
        def stop(self, _ctx=None):
            return _M_Murmur.Server._op_stop.invoke(self, ((), _ctx))

        '''Stop server.'''
        def begin_stop(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_stop.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Stop server.'''
        def end_stop(self, _r):
            return _M_Murmur.Server._op_stop.end(self, _r)

        '''Delete server and all it's configuration.'''
        def delete(self, _ctx=None):
            return _M_Murmur.Server._op_delete.invoke(self, ((), _ctx))

        '''Delete server and all it's configuration.'''
        def begin_delete(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_delete.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Delete server and all it's configuration.'''
        def end_delete(self, _r):
            return _M_Murmur.Server._op_delete.end(self, _r)

        '''Fetch the server id.

Returns:
    Unique server id.'''
        def id(self, _ctx=None):
            return _M_Murmur.Server._op_id.invoke(self, ((), _ctx))

        '''Fetch the server id.

Returns:
    Unique server id.'''
        def begin_id(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_id.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch the server id.

Returns:
    Unique server id.'''
        def end_id(self, _r):
            return _M_Murmur.Server._op_id.end(self, _r)

        '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
        def addCallback(self, cb, _ctx=None):
            return _M_Murmur.Server._op_addCallback.invoke(self, ((cb, ), _ctx))

        '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
        def begin_addCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Add a callback. The callback will receive notifications about changes to users and channels.

Arguments:
    cb Callback interface which will receive notifications.'''
        def end_addCallback(self, _r):
            return _M_Murmur.Server._op_addCallback.end(self, _r)

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def removeCallback(self, cb, _ctx=None):
            return _M_Murmur.Server._op_removeCallback.invoke(self, ((cb, ), _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def begin_removeCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def end_removeCallback(self, _r):
            return _M_Murmur.Server._op_removeCallback.end(self, _r)

        '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
        def setAuthenticator(self, auth, _ctx=None):
            return _M_Murmur.Server._op_setAuthenticator.invoke(self, ((auth, ), _ctx))

        '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
        def begin_setAuthenticator(self, auth, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setAuthenticator.begin(self, ((auth, ), _response, _ex, _sent, _ctx))

        '''Set external authenticator. If set, all authentications from clients are forwarded to this
proxy.

Arguments:
    auth Authenticator object to perform subsequent authentications.'''
        def end_setAuthenticator(self, _r):
            return _M_Murmur.Server._op_setAuthenticator.end(self, _r)

        '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see [Meta::getDefaultConf]'''
        def getConf(self, key, _ctx=None):
            return _M_Murmur.Server._op_getConf.invoke(self, ((key, ), _ctx))

        '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see [Meta::getDefaultConf]'''
        def begin_getConf(self, key, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getConf.begin(self, ((key, ), _response, _ex, _sent, _ctx))

        '''Retrieve configuration item.
Arguments:
    key Configuration key.
Returns:
    Configuration value. If this is empty, see [Meta::getDefaultConf]'''
        def end_getConf(self, _r):
            return _M_Murmur.Server._op_getConf.end(self, _r)

        '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from [Meta::getDefaultConf] is used.'''
        def getAllConf(self, _ctx=None):
            return _M_Murmur.Server._op_getAllConf.invoke(self, ((), _ctx))

        '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from [Meta::getDefaultConf] is used.'''
        def begin_getAllConf(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getAllConf.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve all configuration items.
Returns:
    All configured values. If a value isn't set here, the value from [Meta::getDefaultConf] is used.'''
        def end_getAllConf(self, _r):
            return _M_Murmur.Server._op_getAllConf.end(self, _r)

        '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
        def setConf(self, key, value, _ctx=None):
            return _M_Murmur.Server._op_setConf.invoke(self, ((key, value), _ctx))

        '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
        def begin_setConf(self, key, value, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setConf.begin(self, ((key, value), _response, _ex, _sent, _ctx))

        '''Set a configuration item.
Arguments:
    key Configuration key.
    value Configuration value.'''
        def end_setConf(self, _r):
            return _M_Murmur.Server._op_setConf.end(self, _r)

        '''Set superuser password. This is just a convenience for using [updateRegistration] on user id 0.
Arguments:
    pw Password.'''
        def setSuperuserPassword(self, pw, _ctx=None):
            return _M_Murmur.Server._op_setSuperuserPassword.invoke(self, ((pw, ), _ctx))

        '''Set superuser password. This is just a convenience for using [updateRegistration] on user id 0.
Arguments:
    pw Password.'''
        def begin_setSuperuserPassword(self, pw, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setSuperuserPassword.begin(self, ((pw, ), _response, _ex, _sent, _ctx))

        '''Set superuser password. This is just a convenience for using [updateRegistration] on user id 0.
Arguments:
    pw Password.'''
        def end_setSuperuserPassword(self, _r):
            return _M_Murmur.Server._op_setSuperuserPassword.end(self, _r)

        '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
        def getLog(self, first, last, _ctx=None):
            return _M_Murmur.Server._op_getLog.invoke(self, ((first, last), _ctx))

        '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
        def begin_getLog(self, first, last, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getLog.begin(self, ((first, last), _response, _ex, _sent, _ctx))

        '''Fetch log entries.
Arguments:
    first Lowest numbered entry to fetch. 0 is the most recent item.
    last Last entry to fetch.
Returns:
    List of log entries.'''
        def end_getLog(self, _r):
            return _M_Murmur.Server._op_getLog.end(self, _r)

        '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
        def getUsers(self, _ctx=None):
            return _M_Murmur.Server._op_getUsers.invoke(self, ((), _ctx))

        '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
        def begin_getUsers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUsers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all users. This returns all currently connected users on the server.
Returns:
    List of connected users.'''
        def end_getUsers(self, _r):
            return _M_Murmur.Server._op_getUsers.end(self, _r)

        '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
        def getChannels(self, _ctx=None):
            return _M_Murmur.Server._op_getChannels.invoke(self, ((), _ctx))

        '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
        def begin_getChannels(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getChannels.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
Returns:
    List of defined channels.'''
        def end_getChannels(self, _r):
            return _M_Murmur.Server._op_getChannels.end(self, _r)

        '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    Certificate list of user.'''
        def getCertificateList(self, session, _ctx=None):
            return _M_Murmur.Server._op_getCertificateList.invoke(self, ((session, ), _ctx))

        '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    Certificate list of user.'''
        def begin_getCertificateList(self, session, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getCertificateList.begin(self, ((session, ), _response, _ex, _sent, _ctx))

        '''Fetch certificate of user. This returns the complete certificate chain of a user.
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    Certificate list of user.'''
        def end_getCertificateList(self, _r):
            return _M_Murmur.Server._op_getCertificateList.end(self, _r)

        '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
        def getTree(self, _ctx=None):
            return _M_Murmur.Server._op_getTree.invoke(self, ((), _ctx))

        '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
        def begin_getTree(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getTree.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
as a tree. This is primarily used for viewing the state of the server on a webpage.
Returns:
    Recursive tree of all channels and connected users.'''
        def end_getTree(self, _r):
            return _M_Murmur.Server._op_getTree.end(self, _r)

        '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
        def getBans(self, _ctx=None):
            return _M_Murmur.Server._op_getBans.invoke(self, ((), _ctx))

        '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
        def begin_getBans(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getBans.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch all current IP bans on the server.
Returns:
    List of bans.'''
        def end_getBans(self, _r):
            return _M_Murmur.Server._op_getBans.end(self, _r)

        '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call [getBans] and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
        def setBans(self, bans, _ctx=None):
            return _M_Murmur.Server._op_setBans.invoke(self, ((bans, ), _ctx))

        '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call [getBans] and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
        def begin_setBans(self, bans, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setBans.begin(self, ((bans, ), _response, _ex, _sent, _ctx))

        '''Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call [getBans] and then
append to the returned list before calling this method.
Arguments:
    bans List of bans.'''
        def end_setBans(self, _r):
            return _M_Murmur.Server._op_setBans.end(self, _r)

        '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See [User::session].
    reason Text message to show when user is kicked.'''
        def kickUser(self, session, reason, _ctx=None):
            return _M_Murmur.Server._op_kickUser.invoke(self, ((session, reason), _ctx))

        '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See [User::session].
    reason Text message to show when user is kicked.'''
        def begin_kickUser(self, session, reason, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_kickUser.begin(self, ((session, reason), _response, _ex, _sent, _ctx))

        '''Kick a user. The user is not banned, and is free to rejoin the server.
Arguments:
    session Connection ID of user. See [User::session].
    reason Text message to show when user is kicked.'''
        def end_kickUser(self, _r):
            return _M_Murmur.Server._op_kickUser.end(self, _r)

        '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    State of connected user.'''
        def getState(self, session, _ctx=None):
            return _M_Murmur.Server._op_getState.invoke(self, ((session, ), _ctx))

        '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    State of connected user.'''
        def begin_getState(self, session, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getState.begin(self, ((session, ), _response, _ex, _sent, _ctx))

        '''Get state of a single connected user. 
Arguments:
    session Connection ID of user. See [User::session].
Returns:
    State of connected user.'''
        def end_getState(self, _r):
            return _M_Murmur.Server._op_getState.end(self, _r)

        '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
        def setState(self, state, _ctx=None):
            return _M_Murmur.Server._op_setState.invoke(self, ((state, ), _ctx))

        '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
        def begin_setState(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setState.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Set user state. You can use this to move, mute and deafen users.
Arguments:
    state User state to set.'''
        def end_setState(self, _r):
            return _M_Murmur.Server._op_setState.end(self, _r)

        '''Send text message to a single user.
Arguments:
    session Connection ID of user. See [User::session].
    text Message to send.'''
        def sendMessage(self, session, text, _ctx=None):
            return _M_Murmur.Server._op_sendMessage.invoke(self, ((session, text), _ctx))

        '''Send text message to a single user.
Arguments:
    session Connection ID of user. See [User::session].
    text Message to send.'''
        def begin_sendMessage(self, session, text, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_sendMessage.begin(self, ((session, text), _response, _ex, _sent, _ctx))

        '''Send text message to a single user.
Arguments:
    session Connection ID of user. See [User::session].
    text Message to send.'''
        def end_sendMessage(self, _r):
            return _M_Murmur.Server._op_sendMessage.end(self, _r)

        '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See [User::session].
    channelid ID of Channel. See [Channel::id].
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
        def hasPermission(self, session, channelid, perm, _ctx=None):
            return _M_Murmur.Server._op_hasPermission.invoke(self, ((session, channelid, perm), _ctx))

        '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See [User::session].
    channelid ID of Channel. See [Channel::id].
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
        def begin_hasPermission(self, session, channelid, perm, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_hasPermission.begin(self, ((session, channelid, perm), _response, _ex, _sent, _ctx))

        '''Check if user is permitted to perform action.
Arguments:
    session Connection ID of user. See [User::session].
    channelid ID of Channel. See [Channel::id].
    perm Permission bits to check.
Returns:
    true if any of the permissions in perm were set for the user.'''
        def end_hasPermission(self, _r):
            return _M_Murmur.Server._op_hasPermission.end(self, _r)

        '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of [ContextServer], [ContextChannel] and [ContextUser].'''
        def addContextCallback(self, session, action, text, cb, ctx, _ctx=None):
            return _M_Murmur.Server._op_addContextCallback.invoke(self, ((session, action, text, cb, ctx), _ctx))

        '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of [ContextServer], [ContextChannel] and [ContextUser].'''
        def begin_addContextCallback(self, session, action, text, cb, ctx, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addContextCallback.begin(self, ((session, action, text, cb, ctx), _response, _ex, _sent, _ctx))

        '''Add a context callback. This is done per user, and will add a context menu action for the user.

Arguments:
    session Session of user which should receive context entry.
    action Action string, a unique name to associate with the action.
    text Name of action shown to user.
    cb Callback interface which will receive notifications.
    ctx Context this should be used in. Needs to be one or a combination of [ContextServer], [ContextChannel] and [ContextUser].'''
        def end_addContextCallback(self, _r):
            return _M_Murmur.Server._op_addContextCallback.end(self, _r)

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
        def removeContextCallback(self, cb, _ctx=None):
            return _M_Murmur.Server._op_removeContextCallback.invoke(self, ((cb, ), _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
        def begin_removeContextCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeContextCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed. This callback will be removed from all from all users.'''
        def end_removeContextCallback(self, _r):
            return _M_Murmur.Server._op_removeContextCallback.end(self, _r)

        '''Get state of single channel.
Arguments:
    channelid ID of Channel. See [Channel::id].
Returns:
    State of channel.'''
        def getChannelState(self, channelid, _ctx=None):
            return _M_Murmur.Server._op_getChannelState.invoke(self, ((channelid, ), _ctx))

        '''Get state of single channel.
Arguments:
    channelid ID of Channel. See [Channel::id].
Returns:
    State of channel.'''
        def begin_getChannelState(self, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getChannelState.begin(self, ((channelid, ), _response, _ex, _sent, _ctx))

        '''Get state of single channel.
Arguments:
    channelid ID of Channel. See [Channel::id].
Returns:
    State of channel.'''
        def end_getChannelState(self, _r):
            return _M_Murmur.Server._op_getChannelState.end(self, _r)

        '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
        def setChannelState(self, state, _ctx=None):
            return _M_Murmur.Server._op_setChannelState.invoke(self, ((state, ), _ctx))

        '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
        def begin_setChannelState(self, state, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setChannelState.begin(self, ((state, ), _response, _ex, _sent, _ctx))

        '''Set state of a single channel. You can use this to move or relink channels.
Arguments:
    state Channel state to set.'''
        def end_setChannelState(self, _r):
            return _M_Murmur.Server._op_setChannelState.end(self, _r)

        '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See [Channel::id].'''
        def removeChannel(self, channelid, _ctx=None):
            return _M_Murmur.Server._op_removeChannel.invoke(self, ((channelid, ), _ctx))

        '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See [Channel::id].'''
        def begin_removeChannel(self, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeChannel.begin(self, ((channelid, ), _response, _ex, _sent, _ctx))

        '''Remove a channel and all its subchannels.
Arguments:
    channelid ID of Channel. See [Channel::id].'''
        def end_removeChannel(self, _r):
            return _M_Murmur.Server._op_removeChannel.end(self, _r)

        '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See [Channel::id].
Returns:
    ID of newly created channel.'''
        def addChannel(self, name, parent, _ctx=None):
            return _M_Murmur.Server._op_addChannel.invoke(self, ((name, parent), _ctx))

        '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See [Channel::id].
Returns:
    ID of newly created channel.'''
        def begin_addChannel(self, name, parent, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addChannel.begin(self, ((name, parent), _response, _ex, _sent, _ctx))

        '''Add a new channel.
Arguments:
    name Name of new channel.
    parent Channel ID of parent channel. See [Channel::id].
Returns:
    ID of newly created channel.'''
        def end_addChannel(self, _r):
            return _M_Murmur.Server._op_addChannel.end(self, _r)

        '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See [Channel::id].
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
        def sendMessageChannel(self, channelid, tree, text, _ctx=None):
            return _M_Murmur.Server._op_sendMessageChannel.invoke(self, ((channelid, tree, text), _ctx))

        '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See [Channel::id].
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
        def begin_sendMessageChannel(self, channelid, tree, text, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_sendMessageChannel.begin(self, ((channelid, tree, text), _response, _ex, _sent, _ctx))

        '''Send text message to channel or a tree of channels.
Arguments:
    channelid Channel ID of channel to send to. See [Channel::id].
    tree If true, the message will be sent to the channel and all its subchannels.
    text Message to send.'''
        def end_sendMessageChannel(self, _r):
            return _M_Murmur.Server._op_sendMessageChannel.end(self, _r)

        '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
        def getACL(self, channelid, _ctx=None):
            return _M_Murmur.Server._op_getACL.invoke(self, ((channelid, ), _ctx))

        '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
        def begin_getACL(self, channelid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getACL.begin(self, ((channelid, ), _response, _ex, _sent, _ctx))

        '''Retrieve ACLs and Groups on a channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel. This will include inherited ACLs.
    groups List of groups on the channel. This will include inherited groups.
    inherit Does this channel inherit ACLs from the parent channel?'''
        def end_getACL(self, _r):
            return _M_Murmur.Server._op_getACL.end(self, _r)

        '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
        def setACL(self, channelid, acls, groups, inherit, _ctx=None):
            return _M_Murmur.Server._op_setACL.invoke(self, ((channelid, acls, groups, inherit), _ctx))

        '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
        def begin_setACL(self, channelid, acls, groups, inherit, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setACL.begin(self, ((channelid, acls, groups, inherit), _response, _ex, _sent, _ctx))

        '''Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
Arguments:
    channelid Channel ID of channel to fetch from. See [Channel::id].
    acls List of ACLs on the channel.
    groups List of groups on the channel.
    inherit Should this channel inherit ACLs from the parent channel?'''
        def end_setACL(self, _r):
            return _M_Murmur.Server._op_setACL.end(self, _r)

        '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to add to.'''
        def addUserToGroup(self, channelid, session, group, _ctx=None):
            return _M_Murmur.Server._op_addUserToGroup.invoke(self, ((channelid, session, group), _ctx))

        '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to add to.'''
        def begin_addUserToGroup(self, channelid, session, group, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_addUserToGroup.begin(self, ((channelid, session, group), _response, _ex, _sent, _ctx))

        '''Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to add to.'''
        def end_addUserToGroup(self, _r):
            return _M_Murmur.Server._op_addUserToGroup.end(self, _r)

        '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to remove from.'''
        def removeUserFromGroup(self, channelid, session, group, _ctx=None):
            return _M_Murmur.Server._op_removeUserFromGroup.invoke(self, ((channelid, session, group), _ctx))

        '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to remove from.'''
        def begin_removeUserFromGroup(self, channelid, session, group, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_removeUserFromGroup.begin(self, ((channelid, session, group), _response, _ex, _sent, _ctx))

        '''Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
Arguments:
    channelid Channel ID of channel to add to. See [Channel::id].
    session Connection ID of user. See [User::session].
    group Group name to remove from.'''
        def end_removeUserFromGroup(self, _r):
            return _M_Murmur.Server._op_removeUserFromGroup.end(self, _r)

        '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See [User::session].
    source Group name to redirect from.
    target Group name to redirect to.'''
        def redirectWhisperGroup(self, session, source, target, _ctx=None):
            return _M_Murmur.Server._op_redirectWhisperGroup.invoke(self, ((session, source, target), _ctx))

        '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See [User::session].
    source Group name to redirect from.
    target Group name to redirect to.'''
        def begin_redirectWhisperGroup(self, session, source, target, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_redirectWhisperGroup.begin(self, ((session, source, target), _response, _ex, _sent, _ctx))

        '''Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
To remove a redirect pass an empty target string. This is intended for context groups.
Arguments:
    session Connection ID of user. See [User::session].
    source Group name to redirect from.
    target Group name to redirect to.'''
        def end_redirectWhisperGroup(self, _r):
            return _M_Murmur.Server._op_redirectWhisperGroup.end(self, _r)

        '''Map a list of [User::userid] to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
        def getUserNames(self, ids, _ctx=None):
            return _M_Murmur.Server._op_getUserNames.invoke(self, ((ids, ), _ctx))

        '''Map a list of [User::userid] to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
        def begin_getUserNames(self, ids, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUserNames.begin(self, ((ids, ), _response, _ex, _sent, _ctx))

        '''Map a list of [User::userid] to a matching name.
Arguments:
    List of ids.
Returns:
    Matching list of names, with an empty string representing invalid or unknown ids.'''
        def end_getUserNames(self, _r):
            return _M_Murmur.Server._op_getUserNames.end(self, _r)

        '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
        def getUserIds(self, names, _ctx=None):
            return _M_Murmur.Server._op_getUserIds.invoke(self, ((names, ), _ctx))

        '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
        def begin_getUserIds(self, names, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUserIds.begin(self, ((names, ), _response, _ex, _sent, _ctx))

        '''Map a list of user names to a matching id.
Arguments:
    List of names.
@reuturn List of matching ids, with -1 representing invalid or unknown user names.'''
        def end_getUserIds(self, _r):
            return _M_Murmur.Server._op_getUserIds.end(self, _r)

        '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See [RegisteredUser::userid].'''
        def registerUser(self, info, _ctx=None):
            return _M_Murmur.Server._op_registerUser.invoke(self, ((info, ), _ctx))

        '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See [RegisteredUser::userid].'''
        def begin_registerUser(self, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_registerUser.begin(self, ((info, ), _response, _ex, _sent, _ctx))

        '''Register a new user.
Arguments:
    info Information about new user. Must include at least "name".
Returns:
    The ID of the user. See [RegisteredUser::userid].'''
        def end_registerUser(self, _r):
            return _M_Murmur.Server._op_registerUser.end(self, _r)

        '''Remove a user registration.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].'''
        def unregisterUser(self, userid, _ctx=None):
            return _M_Murmur.Server._op_unregisterUser.invoke(self, ((userid, ), _ctx))

        '''Remove a user registration.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].'''
        def begin_unregisterUser(self, userid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_unregisterUser.begin(self, ((userid, ), _response, _ex, _sent, _ctx))

        '''Remove a user registration.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].'''
        def end_unregisterUser(self, _r):
            return _M_Murmur.Server._op_unregisterUser.end(self, _r)

        '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
        def updateRegistration(self, userid, info, _ctx=None):
            return _M_Murmur.Server._op_updateRegistration.invoke(self, ((userid, info), _ctx))

        '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
        def begin_updateRegistration(self, userid, info, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_updateRegistration.begin(self, ((userid, info), _response, _ex, _sent, _ctx))

        '''Update the registration for a user. You can use this to set the email or password of a user,
and can also use it to change the user's name.
Arguments:
    registration Updated registration record.'''
        def end_updateRegistration(self, _r):
            return _M_Murmur.Server._op_updateRegistration.end(self, _r)

        '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Registration record.'''
        def getRegistration(self, userid, _ctx=None):
            return _M_Murmur.Server._op_getRegistration.invoke(self, ((userid, ), _ctx))

        '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Registration record.'''
        def begin_getRegistration(self, userid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getRegistration.begin(self, ((userid, ), _response, _ex, _sent, _ctx))

        '''Fetch registration for a single user.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Registration record.'''
        def end_getRegistration(self, _r):
            return _M_Murmur.Server._op_getRegistration.end(self, _r)

        '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
        def getRegisteredUsers(self, filter, _ctx=None):
            return _M_Murmur.Server._op_getRegisteredUsers.invoke(self, ((filter, ), _ctx))

        '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
        def begin_getRegisteredUsers(self, filter, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getRegisteredUsers.begin(self, ((filter, ), _response, _ex, _sent, _ctx))

        '''Fetch a group of registered users.
Arguments:
    filter Substring of user name. If blank, will retrieve all registered users.
Returns:
    List of registration records.'''
        def end_getRegisteredUsers(self, _r):
            return _M_Murmur.Server._op_getRegisteredUsers.end(self, _r)

        '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See [RegisteredUser::name].
    pw User password.
Returns:
    User ID of registered user (See [RegisteredUser::userid]), -1 for failed authentication or -2 for unknown usernames.'''
        def verifyPassword(self, name, pw, _ctx=None):
            return _M_Murmur.Server._op_verifyPassword.invoke(self, ((name, pw), _ctx))

        '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See [RegisteredUser::name].
    pw User password.
Returns:
    User ID of registered user (See [RegisteredUser::userid]), -1 for failed authentication or -2 for unknown usernames.'''
        def begin_verifyPassword(self, name, pw, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_verifyPassword.begin(self, ((name, pw), _response, _ex, _sent, _ctx))

        '''Verify the password of a user. You can use this to verify a user's credentials.
Arguments:
    name User name. See [RegisteredUser::name].
    pw User password.
Returns:
    User ID of registered user (See [RegisteredUser::userid]), -1 for failed authentication or -2 for unknown usernames.'''
        def end_verifyPassword(self, _r):
            return _M_Murmur.Server._op_verifyPassword.end(self, _r)

        '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Custom texture associated with user or an empty texture.'''
        def getTexture(self, userid, _ctx=None):
            return _M_Murmur.Server._op_getTexture.invoke(self, ((userid, ), _ctx))

        '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Custom texture associated with user or an empty texture.'''
        def begin_getTexture(self, userid, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getTexture.begin(self, ((userid, ), _response, _ex, _sent, _ctx))

        '''Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
Returns:
    Custom texture associated with user or an empty texture.'''
        def end_getTexture(self, _r):
            return _M_Murmur.Server._op_getTexture.end(self, _r)

        '''Set user texture. The texture is a 600x60 32-bit BGRA raw texture, optionally zlib compress()ed.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
    tex Texture to set for the user, or an empty texture to remove the existing texture.'''
        def setTexture(self, userid, tex, _ctx=None):
            return _M_Murmur.Server._op_setTexture.invoke(self, ((userid, tex), _ctx))

        '''Set user texture. The texture is a 600x60 32-bit BGRA raw texture, optionally zlib compress()ed.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
    tex Texture to set for the user, or an empty texture to remove the existing texture.'''
        def begin_setTexture(self, userid, tex, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_setTexture.begin(self, ((userid, tex), _response, _ex, _sent, _ctx))

        '''Set user texture. The texture is a 600x60 32-bit BGRA raw texture, optionally zlib compress()ed.
Arguments:
    userid ID of registered user. See [RegisteredUser::userid].
    tex Texture to set for the user, or an empty texture to remove the existing texture.'''
        def end_setTexture(self, _r):
            return _M_Murmur.Server._op_setTexture.end(self, _r)

        '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
        def getUptime(self, _ctx=None):
            return _M_Murmur.Server._op_getUptime.invoke(self, ((), _ctx))

        '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
        def begin_getUptime(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Server._op_getUptime.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get virtual server uptime.
Returns:
    Uptime of the virtual server in seconds'''
        def end_getUptime(self, _r):
            return _M_Murmur.Server._op_getUptime.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.ServerPrx.ice_checkedCast(proxy, '::Murmur::Server', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_ServerPrx = IcePy.defineProxy('::Murmur::Server', ServerPrx)

    _M_Murmur._t_Server = IcePy.defineClass('::Murmur::Server', Server, (), True, None, (), ())
    Server._ice_type = _M_Murmur._t_Server

    Server._op_isRunning = IcePy.Operation('isRunning', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), IcePy._t_bool, ())
    Server._op_start = IcePy.Operation('start', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_ServerFailureException))
    Server._op_stop = IcePy.Operation('stop', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (), (), None, (_M_Murmur._t_ServerBootedException,))
    Server._op_delete = IcePy.Operation('delete', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (), (), None, (_M_Murmur._t_ServerBootedException,))
    Server._op_id = IcePy.Operation('id', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), IcePy._t_int, ())
    Server._op_addCallback = IcePy.Operation('addCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), _M_Murmur._t_ServerCallbackPrx),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException))
    Server._op_removeCallback = IcePy.Operation('removeCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), _M_Murmur._t_ServerCallbackPrx),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException))
    Server._op_setAuthenticator = IcePy.Operation('setAuthenticator', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), _M_Murmur._t_ServerAuthenticatorPrx),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException))
    Server._op_getConf = IcePy.Operation('getConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_string),), (), IcePy._t_string, ())
    Server._op_getAllConf = IcePy.Operation('getAllConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_ConfigMap, ())
    Server._op_setConf = IcePy.Operation('setConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_string), ((), IcePy._t_string)), (), None, ())
    Server._op_setSuperuserPassword = IcePy.Operation('setSuperuserPassword', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_string),), (), None, ())
    Server._op_getLog = IcePy.Operation('getLog', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int), ((), IcePy._t_int)), (), _M_Murmur._t_LogList, ())
    Server._op_getUsers = IcePy.Operation('getUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_UserMap, (_M_Murmur._t_ServerBootedException,))
    Server._op_getChannels = IcePy.Operation('getChannels', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_ChannelMap, (_M_Murmur._t_ServerBootedException,))
    Server._op_getCertificateList = IcePy.Operation('getCertificateList', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int),), (), _M_Murmur._t_CertificateList, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException))
    Server._op_getTree = IcePy.Operation('getTree', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_Tree, (_M_Murmur._t_ServerBootedException,))
    Server._op_getBans = IcePy.Operation('getBans', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_BanList, (_M_Murmur._t_ServerBootedException,))
    Server._op_setBans = IcePy.Operation('setBans', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), _M_Murmur._t_BanList),), (), None, (_M_Murmur._t_ServerBootedException,))
    Server._op_kickUser = IcePy.Operation('kickUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_int), ((), IcePy._t_string)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException))
    Server._op_getState = IcePy.Operation('getState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int),), (), _M_Murmur._t_User, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException))
    Server._op_setState = IcePy.Operation('setState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), _M_Murmur._t_User),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException))
    Server._op_sendMessage = IcePy.Operation('sendMessage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_int), ((), IcePy._t_string)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException))
    Server._op_hasPermission = IcePy.Operation('hasPermission', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_int), ((), IcePy._t_int), ((), IcePy._t_int)), (), IcePy._t_bool, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException))
    Server._op_addContextCallback = IcePy.Operation('addContextCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_int), ((), IcePy._t_string), ((), IcePy._t_string), ((), _M_Murmur._t_ServerContextCallbackPrx), ((), IcePy._t_int)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException))
    Server._op_removeContextCallback = IcePy.Operation('removeContextCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), _M_Murmur._t_ServerContextCallbackPrx),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException))
    Server._op_getChannelState = IcePy.Operation('getChannelState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int),), (), _M_Murmur._t_Channel, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException))
    Server._op_setChannelState = IcePy.Operation('setChannelState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), _M_Murmur._t_Channel),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException))
    Server._op_removeChannel = IcePy.Operation('removeChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_int),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException))
    Server._op_addChannel = IcePy.Operation('addChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_string), ((), IcePy._t_int)), (), IcePy._t_int, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException))
    Server._op_sendMessageChannel = IcePy.Operation('sendMessageChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_int), ((), IcePy._t_bool), ((), IcePy._t_string)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException))
    Server._op_getACL = IcePy.Operation('getACL', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int),), (((), _M_Murmur._t_ACLList), ((), _M_Murmur._t_GroupList), ((), IcePy._t_bool)), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException))
    Server._op_setACL = IcePy.Operation('setACL', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int), ((), _M_Murmur._t_ACLList), ((), _M_Murmur._t_GroupList), ((), IcePy._t_bool)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException))
    Server._op_addUserToGroup = IcePy.Operation('addUserToGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int), ((), IcePy._t_int), ((), IcePy._t_string)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSessionException))
    Server._op_removeUserFromGroup = IcePy.Operation('removeUserFromGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int), ((), IcePy._t_int), ((), IcePy._t_string)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSessionException))
    Server._op_redirectWhisperGroup = IcePy.Operation('redirectWhisperGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int), ((), IcePy._t_string), ((), IcePy._t_string)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException))
    Server._op_getUserNames = IcePy.Operation('getUserNames', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), _M_Murmur._t_IdList),), (), _M_Murmur._t_NameMap, (_M_Murmur._t_ServerBootedException,))
    Server._op_getUserIds = IcePy.Operation('getUserIds', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), _M_Murmur._t_NameList),), (), _M_Murmur._t_IdMap, (_M_Murmur._t_ServerBootedException,))
    Server._op_registerUser = IcePy.Operation('registerUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), _M_Murmur._t_UserInfoMap),), (), IcePy._t_int, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException))
    Server._op_unregisterUser = IcePy.Operation('unregisterUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), IcePy._t_int),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException))
    Server._op_updateRegistration = IcePy.Operation('updateRegistration', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int), ((), _M_Murmur._t_UserInfoMap)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException))
    Server._op_getRegistration = IcePy.Operation('getRegistration', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int),), (), _M_Murmur._t_UserInfoMap, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException))
    Server._op_getRegisteredUsers = IcePy.Operation('getRegisteredUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_string),), (), _M_Murmur._t_NameMap, (_M_Murmur._t_ServerBootedException,))
    Server._op_verifyPassword = IcePy.Operation('verifyPassword', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_string), ((), IcePy._t_string)), (), IcePy._t_int, (_M_Murmur._t_ServerBootedException,))
    Server._op_getTexture = IcePy.Operation('getTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int),), (), _M_Murmur._t_Texture, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException))
    Server._op_setTexture = IcePy.Operation('setTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int), ((), _M_Murmur._t_Texture)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidTextureException))
    Server._op_getUptime = IcePy.Operation('getUptime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), IcePy._t_int, (_M_Murmur._t_ServerBootedException,))

    _M_Murmur.Server = Server
    del Server

    _M_Murmur.ServerPrx = ServerPrx
    del ServerPrx

if not _M_Murmur.__dict__.has_key('MetaCallback'):
    _M_Murmur.MetaCallback = Ice.createTempClass()
    class MetaCallback(Ice.Object):
        '''Callback interface for Meta. You can supply an implementation of this to recieve notifications
when servers are stopped or started.
If an added callback ever throws an exception or goes away, it will be automatically removed.
Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
complete before continuing processing.'''
        def __init__(self):
            if __builtin__.type(self) == _M_Murmur.MetaCallback:
                raise RuntimeError('Murmur.MetaCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::MetaCallback')

        def ice_id(self, current=None):
            return '::Murmur::MetaCallback'

        def ice_staticId():
            return '::Murmur::MetaCallback'
        ice_staticId = staticmethod(ice_staticId)

        def started(self, srv, current=None):
            '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
            pass

        def stopped(self, srv, current=None):
            '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_MetaCallback)

        __repr__ = __str__

    _M_Murmur.MetaCallbackPrx = Ice.createTempClass()
    class MetaCallbackPrx(Ice.ObjectPrx):

        '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def started(self, srv, _ctx=None):
            return _M_Murmur.MetaCallback._op_started.invoke(self, ((srv, ), _ctx))

        '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def begin_started(self, srv, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.MetaCallback._op_started.begin(self, ((srv, ), _response, _ex, _sent, _ctx))

        '''Called when a server is started. The server is up and running when this event is sent, so all methods that 
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def end_started(self, _r):
            return _M_Murmur.MetaCallback._op_started.end(self, _r)

        '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def stopped(self, srv, _ctx=None):
            return _M_Murmur.MetaCallback._op_stopped.invoke(self, ((srv, ), _ctx))

        '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def begin_stopped(self, srv, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.MetaCallback._op_stopped.begin(self, ((srv, ), _response, _ex, _sent, _ctx))

        '''Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
need a running server will work.
Arguments:
    srv Interface for started server.'''
        def end_stopped(self, _r):
            return _M_Murmur.MetaCallback._op_stopped.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.MetaCallbackPrx.ice_checkedCast(proxy, '::Murmur::MetaCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.MetaCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_MetaCallbackPrx = IcePy.defineProxy('::Murmur::MetaCallback', MetaCallbackPrx)

    _M_Murmur._t_MetaCallback = IcePy.defineClass('::Murmur::MetaCallback', MetaCallback, (), True, None, (), ())
    MetaCallback._ice_type = _M_Murmur._t_MetaCallback

    MetaCallback._op_started = IcePy.Operation('started', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), _M_Murmur._t_ServerPrx),), (), None, ())
    MetaCallback._op_stopped = IcePy.Operation('stopped', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), _M_Murmur._t_ServerPrx),), (), None, ())

    _M_Murmur.MetaCallback = MetaCallback
    del MetaCallback

    _M_Murmur.MetaCallbackPrx = MetaCallbackPrx
    del MetaCallbackPrx

if not _M_Murmur.__dict__.has_key('_t_ServerList'):
    _M_Murmur._t_ServerList = IcePy.defineSequence('::Murmur::ServerList', (), _M_Murmur._t_ServerPrx)

if not _M_Murmur.__dict__.has_key('Meta'):
    _M_Murmur.Meta = Ice.createTempClass()
    class Meta(Ice.Object):
        '''This is the meta interface. It is primarily used for retrieving the [Server] interfaces for each individual server.'''
        def __init__(self):
            if __builtin__.type(self) == _M_Murmur.Meta:
                raise RuntimeError('Murmur.Meta is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Meta')

        def ice_id(self, current=None):
            return '::Murmur::Meta'

        def ice_staticId():
            return '::Murmur::Meta'
        ice_staticId = staticmethod(ice_staticId)

        def getServer_async(self, _cb, id, current=None):
            '''Fetch interface to specific server.
Arguments:
    id Server ID. See [Server::getId].
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
            pass

        def newServer_async(self, _cb, current=None):
            '''Create a new server. Call [Server::getId] on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
            pass

        def getBootedServers_async(self, _cb, current=None):
            '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
            pass

        def getAllServers_async(self, _cb, current=None):
            '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
            pass

        def getDefaultConf_async(self, _cb, current=None):
            '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
            pass

        def getVersion_async(self, _cb, current=None):
            '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the [major], [minor] and [patch] levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
            pass

        def addCallback_async(self, _cb, cb, current=None):
            '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
            pass

        def removeCallback_async(self, _cb, cb, current=None):
            '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
            pass

        def getUptime_async(self, _cb, current=None):
            '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Meta)

        __repr__ = __str__

    _M_Murmur.MetaPrx = Ice.createTempClass()
    class MetaPrx(Ice.ObjectPrx):

        '''Fetch interface to specific server.
Arguments:
    id Server ID. See [Server::getId].
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
        def getServer(self, id, _ctx=None):
            return _M_Murmur.Meta._op_getServer.invoke(self, ((id, ), _ctx))

        '''Fetch interface to specific server.
Arguments:
    id Server ID. See [Server::getId].
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
        def begin_getServer(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getServer.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Fetch interface to specific server.
Arguments:
    id Server ID. See [Server::getId].
Returns:
    Interface for specified server, or a null proxy if id is invalid.'''
        def end_getServer(self, _r):
            return _M_Murmur.Meta._op_getServer.end(self, _r)

        '''Create a new server. Call [Server::getId] on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
        def newServer(self, _ctx=None):
            return _M_Murmur.Meta._op_newServer.invoke(self, ((), _ctx))

        '''Create a new server. Call [Server::getId] on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
        def begin_newServer(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_newServer.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Create a new server. Call [Server::getId] on the returned interface to find it's ID.
Returns:
    Interface for new server.'''
        def end_newServer(self, _r):
            return _M_Murmur.Meta._op_newServer.end(self, _r)

        '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
        def getBootedServers(self, _ctx=None):
            return _M_Murmur.Meta._op_getBootedServers.invoke(self, ((), _ctx))

        '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
        def begin_getBootedServers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getBootedServers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch list of all currently running servers.
Returns:
    List of interfaces for running servers.'''
        def end_getBootedServers(self, _r):
            return _M_Murmur.Meta._op_getBootedServers.end(self, _r)

        '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
        def getAllServers(self, _ctx=None):
            return _M_Murmur.Meta._op_getAllServers.invoke(self, ((), _ctx))

        '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
        def begin_getAllServers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getAllServers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch list of all defined servers.
Returns:
    List of interfaces for all servers.'''
        def end_getAllServers(self, _r):
            return _M_Murmur.Meta._op_getAllServers.end(self, _r)

        '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
        def getDefaultConf(self, _ctx=None):
            return _M_Murmur.Meta._op_getDefaultConf.invoke(self, ((), _ctx))

        '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
        def begin_getDefaultConf(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getDefaultConf.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
the built-in default. The individual servers will use these values unless they have been overridden in the
server specific configuration. The only special case is the port, which defaults to the value defined here +
the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
Returns:
    Default configuration of the servers.'''
        def end_getDefaultConf(self, _r):
            return _M_Murmur.Meta._op_getDefaultConf.end(self, _r)

        '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the [major], [minor] and [patch] levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
        def getVersion(self, _ctx=None):
            return _M_Murmur.Meta._op_getVersion.invoke(self, ((), _ctx))

        '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the [major], [minor] and [patch] levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
        def begin_getVersion(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getVersion.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Fetch version of Murmur. 
Arguments:
    major Major version.
    minor Minor version.
    patch Patchlevel.
    text Textual representation of version. Note that this may not match the [major], [minor] and [patch] levels, as it
may be simply the compile date or the SVN revision. This is usually the text you want to present to users.'''
        def end_getVersion(self, _r):
            return _M_Murmur.Meta._op_getVersion.end(self, _r)

        '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
        def addCallback(self, cb, _ctx=None):
            return _M_Murmur.Meta._op_addCallback.invoke(self, ((cb, ), _ctx))

        '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
        def begin_addCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_addCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Add a callback. The callback will receive notifications when servers are started or stopped.

Arguments:
    cb Callback interface which will receive notifications.'''
        def end_addCallback(self, _r):
            return _M_Murmur.Meta._op_addCallback.end(self, _r)

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def removeCallback(self, cb, _ctx=None):
            return _M_Murmur.Meta._op_removeCallback.invoke(self, ((cb, ), _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def begin_removeCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_removeCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Remove a callback.

Arguments:
    cb Callback interface to be removed.'''
        def end_removeCallback(self, _r):
            return _M_Murmur.Meta._op_removeCallback.end(self, _r)

        '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
        def getUptime(self, _ctx=None):
            return _M_Murmur.Meta._op_getUptime.invoke(self, ((), _ctx))

        '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
        def begin_getUptime(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_Murmur.Meta._op_getUptime.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get murmur uptime.
Returns:
    Uptime of murmur in seconds'''
        def end_getUptime(self, _r):
            return _M_Murmur.Meta._op_getUptime.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_Murmur.MetaPrx.ice_checkedCast(proxy, '::Murmur::Meta', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.MetaPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_Murmur._t_MetaPrx = IcePy.defineProxy('::Murmur::Meta', MetaPrx)

    _M_Murmur._t_Meta = IcePy.defineClass('::Murmur::Meta', Meta, (), True, None, (), ())
    Meta._ice_type = _M_Murmur._t_Meta

    Meta._op_getServer = IcePy.Operation('getServer', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (((), IcePy._t_int),), (), _M_Murmur._t_ServerPrx, ())
    Meta._op_newServer = IcePy.Operation('newServer', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (), (), _M_Murmur._t_ServerPrx, ())
    Meta._op_getBootedServers = IcePy.Operation('getBootedServers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_ServerList, ())
    Meta._op_getAllServers = IcePy.Operation('getAllServers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_ServerList, ())
    Meta._op_getDefaultConf = IcePy.Operation('getDefaultConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), _M_Murmur._t_ConfigMap, ())
    Meta._op_getVersion = IcePy.Operation('getVersion', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (((), IcePy._t_int), ((), IcePy._t_int), ((), IcePy._t_int), ((), IcePy._t_string)), None, ())
    Meta._op_addCallback = IcePy.Operation('addCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), _M_Murmur._t_MetaCallbackPrx),), (), None, (_M_Murmur._t_InvalidCallbackException,))
    Meta._op_removeCallback = IcePy.Operation('removeCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, (), (((), _M_Murmur._t_MetaCallbackPrx),), (), None, (_M_Murmur._t_InvalidCallbackException,))
    Meta._op_getUptime = IcePy.Operation('getUptime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, (), (), (), IcePy._t_int, ())

    _M_Murmur.Meta = Meta
    del Meta

    _M_Murmur.MetaPrx = MetaPrx
    del MetaPrx

# End of module Murmur
